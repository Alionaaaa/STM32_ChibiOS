# Инструкция по работе с драйвером PWM

## Что такое PWM?

`PWM` (или же цифровая ШИМ) - это драйвер, генерирующий на ноге контроллера прямоугольный сигнал. Драйвер использует таймер, поэтому начать необходимо именно с выбора свободного таймера. Не все таймеры могут опеспечить работу ШИМ. 

## Как выбрать таймер? 

Чтобы понять с какими таймерами можно работать, посмотрим файл `mcuconf.h`, раздел `PWM driver system settings`. 

В случае STM32F767ZI предлагается выбрать из таймеров **1-5** и **8-17**. 
Однако, если выбрать, например, 16, при сборке получим ошибку

```bash
TIM16 not present in the selected device
```

Так что, всё-таки идём читать [документацию](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=39).

Из описания можно получить следующую информацию:

  - `TIM1` и `TIM8` - 16-ти битные advanced таймеры с 4 комплементарными каналами;
  - `TIM2` и `TIM5` - 32-х битные таймеры с 4 каналами;
  - `TIM3` и `TIM4` - 16-ти битные таймеры с 4 каналами;
  - `TIM9` и `TIM12` - 16-ти битные таймеры с двумя каналами;
  - `TIM10`, `TIM11`, `TIM13` и `TIM14` - 16-ти битные таймеры с одним каналом.

Также желаемый таймер должен быть никем не занят. 

> Тут стоит обратить внимание, что как минимум один таймер занят под операционную систему. 
Какой именно смотрим в `mcuconf.h` в дефайне `STM32_ST_USE_TIMER`, в моем случае это второй таймер. Так как по умолчанию `ChibiOS` хочет использовать 32-х битный таймер, поменять можно только на пятый, но если готовы пожертвовать разрешением можно поменять `CH_CFG_ST_RESOLUTION` в `chconf.h` с 32 на 16 и использовать другой таймер, но скорее всего это лишнее.

Каждый канал таймера это какая-то нога, причем как обычно есть несколько вариантов. Смотрим [таблицу](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=89) и ищём что-нибудь вроде `TIM1_CH2`, что означает второй канал первого таймера. 

<p align="center">
<img src="pwm_pics/fig1.png" width=600/>
</p>

У первого и восьмого таймеров каждый канал обозначен двумая ногами, например, `TIM8_CH1` и `TIM8_CH1N`.

<p align="center">
<img src="pwm_pics/fig2.png" width=600/>
</p>

Это особенность **Advanced** таймеров, которая означает, что две ноги могут работать в [комплементарном режиме](http://we.easyelectronics.ru/_YS_/complementary-pwm-i-push-pull-rezhimy-na-taymere-1-kontrollerov-stm32.html#:~:text=%D0%92%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%BD%D0%BE%D0%BC%20%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5%20%D0%B2%D1%82%D0%BE%D1%80%D0%BE%D0%B9%20%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB,%D0%B8%20%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D1%8E%D1%82%20%D0%BA%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82%20%D0%B7%D0%B0%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE.). Причем первый и восьмой таймеры могут работать и в обычном режиме, смотря что установлено в конфигурации.

Выбрав нужные ноги и, соответственно, таймеры, включаем модуль в `halconf.h`, установив `HAL_USE_PWM` в состояние `TRUE`, а также нужный `STM32_PWM_USE_TIMx`. Если нужен комплeментарный режим, также включаем `STM32_PWM_USE_ADVANCED`. Если не понимаешь о чём речь - [смотри сюда](Basics.md)

## Запуск ШИМ

Чтобы запустить драйвер, нужно вызвать функцию 
```c
pwmStart(&pwm_driver, &pwm_config);
```

Имя драйвера `PWMDx` зависит от выбранного таймера. 

Чтобы не запоминать номер таймера и не следить за правильным взятием адреса, можно положить указатель на драйвер в переменную
```c
static PWMDriver *pwm1Driver = &PWMD1;
```

Тогда запуск драйвера будет выглядеть так 
```c
pwmStart(pwm1Driver, &pwm_config);
```

Но просто запустить ШИМ недостаточно, перед этим нужно установить необходимую вам конфигурацию ШИМ.

Структура конфигурации выглядит следующим образом:

```c
typedef struct {
  uint32_t         frequency;             // Частота в герцах
  pwmcnt_t         period;                // Период в тактах
  pwmcallback_t    callback;              // Callback функция, если не требуется, можно установить в NULL
  PWMChannelConfig channels[PWM_CHANNELS] // Структура настройки каналов
  uint32_t         cr2                    // CONTROL_REGISTER2
  uint32_t         bdtr	                  // break and dead-time register. 
  // Используется только для advanced таймеров. 
  // Если advanced режим не включен, НЕ УКАЗЫВАЙТЕ это поле! 
  // Либо получите ошибку (что хорошо), либо вылезете за пределы памяти (очень плохо).
  uint32_t         dier                   // DMA/Interrupt enable register 
} PWMConfig;
```

## Как рассчитать частоту ШИМ? 

Частота ограничена сверху частотой шины, а снизу глубиной предделителя. 

Причем так как предделитель может принимать только **целые значения**, частота тактирования шины должна делиться на желаемую частотау таймера **нацело**.

Таймеры могут висеть на шинах `APB1` или `APB2`. На какой именно шине висит каждый таймер можно посмотреть [тут](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=20).

На картинке видно, что таймеры 2, 3, 4, 5, 6, 7, 12, 13, 14 относятся к `APB1`. А таймеры 1, 8, 9, 10, 11 `APB2`.

<p align="center">
<img src="pwm_pics/fig3.png" width=700/>
</p>

Частота шины вычисляется, как **частота процессора, деленная на предделитель**.

Значение предделителя можно подглядеть в `mcuconf.h`. 

`STM32_PPRE1` является предделителем для `APB1`, а `STM32_PPRE2` для `APB2`. Однако, экспериментально определено, что на самом деле частота таймера может превышать частоту ШИМ в два раза (вероятнее всего, триггером для таймера являются и нарастающий и падающий фронты). 

То есть для первого таймера STM32F767ZI получается, что частота процессора 216МГц, предделитель `APB2`номинально установлен в двойку, а значит максимальная частота 216МГц (216 / 2 \* 2), а минимальная - 3295,898Гц (216000000 / 2^16). Но, так как поле в структуре также должно быть целым, выходит,
что минимальное допустимое значение - 3375 (216000000 / 64000).

## Как рассчитать период ШИМ? 

Период задается в тактах и ограничен разрядностью счетчика. 

То есть если таймер 16-ти битный, нельзя поставить значение периода больше 65 536. 

Соотношение частоты и периода дает итоговую частоту генерируемого сигнала.

> Чтобы посчитать период работы ШИМ можно воспользоваться следующей формулой: PWM_period [s] = period / frequency 

То есть, если частота равна 10000 Гц, а период 100 тактов, частота генерируемого меандра будет 100 Гц. Одной и той же частоты сигнала можно добиться множеством различных конфигураций. Чем больше будет установлена частота тактирования, тем большее разрешение будет у итогового сигнала, а значит, можно будет точнее указать коэффициент заполнения (ширину импульса).

## Как настраивать каналы ШИМ? 

Поле `channels` это массив структур, где каждая структура описывает работу одного канала. 

Размер массива фиксируется по максимальному количеству каналов среди всех таймеров. 

> В случае NUCLEO-F767ZI это 6 каналов на 1 и 8 таймерах (есть вариант работы трёхфазного ШИМ-генератора, независимых каналов всё ещё только 4), но для ясности кода, лучше несуществующие каналы не писать.


Структура описывает работу канала и выглядит она следующим образом:

```c
typedef struct {
  pwmmode_t         mode;           // Режим работы канала
  pwmcallback_t     callback;       // Callback функция, если не требуется, можно установить в NULL
} PWMChannelConfig;
```

Чтобы понять что писать в поля структуры, разберёмся с принципом работы ШИМ. 

В каждый момент времени, каждый канал обусловлен одним из двух состояний: `active` или `idle`. 

Состояние `active` устанавливается после начала нового периода, а состояние `idle` устанавливается после совпадения счётчика со значением, определяющим коэффициент заполениния сигнала. 

Таким образом, время периода складывается из длительности состояний `active` и `idle`. При этом `active` может быть как высоким, так и низким уровнем напряжения.

<p align="center">
<img src="pwm_pics/fig4.png" width="600">
</p>

Таким образом, в поле `mode` можно установить три разных значения:

  - `PWM_OUTPUT_ACTIVE_HIGH` - состояние `active` соответствует высокому уровню напряжения;
  - `PWM_OUTPUT_ACTIVE_LOW` - состояние `idle` соответствует высокому напряжению;
  - `PWM_OUTPUT_DISABLED` - канал выключен.

Если используется advanced таймер, в то же поле через операцию **ИЛИ** надо указать режим комплементарной ноги:

  - `PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH`
  - `PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH`
  - `PWM_OUTPUT_DISABLED`

Например, если необходимы два комплементарных канала четырёхканального таймера, поле `channels` структуры конфигурации драйвера будет выглядеть следующим образом:

```c
.channels = {
        {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
        {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
        {PWM_OUTPUT_DISABLED, NULL},
        {PWM_OUTPUT_DISABLED, NULL}
    },
```

Однако, важно помнить, что комплементарный режим означает работу в противофазе, то есть если нога `TIM1_CH1` находится в состоянии `active`, то нога `TIM1_CH1N` будет в состоянии `idle`. 

Таким образом, если для обеих ног указан режим `ACTIVE_HIGH`, первую часть периода `TIM1_CH1` будет в состоянии высокого напряжения, а `TIM1_CH1N` наоборот в состоянии низкого напряжения.

## Расшифровка остальных конфигов

Поле `cr2` - регистр таймера `CONTROL_REGISTER2`. Теоретически там можно управлять синхранизацией таймеров, но скорее всего не понадобится, так что не думая ставим 0.

Поле `bdtr` - регистр таймера `BREAK_AND_DEAD-TIME_REGISTER`. 

Регистр отвечает за две функции:
- аварийная остановка (BREAK)
- установка мёртвого времени (DEAD-TIME)

Первая функция довольно специфическая и рассмотрена тут не будет, а вот мёртвое время бывает довольно полезно. 

Мёртвое время - это пауза между изменением состояний двух комплементарных ног одного канала. То есть сначала одна нога перейдёт из высокого состояния в низкое, затем пауза и только потом вторая нога перейдёт из низкого состояния в высокое. Это необходимо в силовых мостовых схемах для учёта времени открытия и закрытия транзисторов.

За мёртвое время отвечают только 8 младших бит, причем 5-7 биты выступают в роли предделителей достаточно хитрым образом:

  - Если седьмой бит 0, то мертвое время будет равно `BDTG[6:0]*T_dts`, где `T_dts` - период счётчика мёртвого времени, который в свою очередь зависит от частоты тактирования шины и предделителя;
  - Если седьмой бит 1, а шестой 0, то мёртвое время будет равно `(64 + BDTG[5:0])*2*T_dts`;
  - Если шестой и седьмой биты 1, а пятый 0, то мёртвое время будет равно `(32 + BDTG[4:0])*8*T_dts`;
  - Если биты с пятого по седьмой единицы, то мёртвое время будет равно `(32 + BDTG[4:0])*16*T_dts`.

Предделитель счетчика задается в `CONTROL_REGISTER1`, к которому `ChibiOS` не предлагает обращаться через API, а номинальное значение равно единице, так что, пожалуй, не будем спорить.

Для наглядности, пример:

* Частота шины на первом таймере при номинальном предделителе - 216Мгц, то есть период такта составляет 4,63нс.
* Если установить в поле `bdtr` значение `0b11111111` это будет означать `(32 + 31)*16*4,63*10^(-9)` или же ~4,3мкс.
* Если же необходимо добится паузы в 2мкс, можно пойти обратным путём: `2000/4,63/8=54` (желаемые 2мкс делим на период такта и делим на предделитель 8), 54=32+22, то есть в  `bdtr ` надо положить `0b11010110`.

Последнее поле `dier` - `DMA_INTERRUPT_REGISTER`, отвечает за capture/compare прерывания и прямой доступ к памяти, и тоже скорее всего не понядобится, так что оставляем ноль.

## Примеры конфигураций

В итоге если комплементарный режим не нужен, структура конфигурации выглядит как-то так:
```c
static PWMConfig pwmcfg = {
  .frequency = 500000,
  .period = 10000,
  .callback = NULL,
  .channels = {
   {PWM_OUTPUT_ACTIVE_HIGH, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  .dier = 0
};
```

Если комплиментарный режим нужен, то становится вот так:
```c
static PWMConfig pwmcfg = {
  .frequency = 500000,
  .period = 10000,
  .callback = NULL,
  .channels = {
   {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  .bdtr = 0b11010110,
  .dier = 0
};
```

## Как заполнять callback?

Поле `callback` содержит указатель на функцию, которая будет вызываться в момент перехода канала из состояния `active` в состояние `idle`.

Если хочется, чтобы ШИМ дёргал какую-нибудь функцию, необходимо указать ссылку на эту функцию в поле `callback`. Функция не может ничего возвращать, и должна принимать один аргумент - указатель на драйвер. 
То есть выглядеть она может только так:

```c
void pwmcb_fun(PWMDriver *pwmp)
{
    (void)pwmp; // Это не обязательно, просто чтобы не было ворнингов о неиспользуемой переменной
    ...
    some code
    ...
}
```

Просто указать функцию недостаточно, надо ещё разрешить прерывания, но об этом чуть ниже.

# Что же с этим всем делать

ChibiOS предлагает следующие функции для работы с модулем:

  - `pwmStart(pwm_driver, pwm_config)`
  - `pwmStop(pwm_driver)`
  - `pwmChangePeriod(pwm_driver, period)`
  - `pwmEnableChannel(pwm_driver, channel, width)`
  - `pwmDisableChannel(pwm_driver, channel)`
  - `pwmEnablePeriodicNotification(pwm_driver)`
  - `pwmDisablePeriodicNotification(pwm_driver)`
  - `pwmEnableChannelNotification(pwm_driver, channel)`
  - `pwmDisableChannelNotification(pwm_driver, channel)`

С функциями `pwmStart()` и `pwmStop()`, скорее всего, всё понятно.

`pwmChangePeriod()` позволяет изменить период сигнала во время работы драйвера. Аргументами являются указатель на драйвер и желаемый период в тактах. Частоту тактирования на ходу изменить нельзя, если возникает такая необходимость, надо переопределить структуру конфигурации и перезапустить драйвер.

`pwmEnableChannel()` - начинает генерацию ШИМ сигнала на ноге. Аргументы - указатель на драйвер, номер канала (нумерация начинается с нуля), и ширина импульса в тактах. Для того, чтобы при установке коэффициента заполнения сигнала не зависеть от выбранного периода, есть следующие дефайны:

  - `PWM_FRACTION_TO_WIDTH(driver, denominator, numenator)` - расчёт количества тактов по соотношению в виде числитель/знаменатель. 
  - `PWM_DEGREES_TO_WIDTH(driver, degrees)` - расчёт количества тактов по значению фазы в градусах. Значение задаётся в сотых градуса, так что допустимый диапазон значений [0 36000].
  - `PWM_PERCENTAGE_TO_WIDTH(driver, percentage)` - расчёт количества тактов из процентов. Значение задаётся в сотых процента, так что допустимый диапазон значений [0 10000].

Тут необходимо держать в голове, что как бы точно не была посчитана желаемая длительность импульса, это все еще `int`, то есть в любом случае будет округление. Расчитывайте разрешение сигнала исходя из решаемой задачи.

Изменение длительности импульса обеспечивается повторным вызовом функции `pwmEnableChannel()` с новым значением `width`.

`pwmDisableChannel()` выключает канал, то есть переводит ногу в `idle` состояние и запрещает вызов `callback` функции.

`pwmEnablePeriodicNotification()` разрешает вызов `callback` функций, срабатывающих каждый период. Аргументом является указатель на драйвер. В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()`.

`pwmDisablePeriodicNotification()` запрещает вызов `callback` функций, срабатывающих каждый период. Аргументом является указатель на драйвер. В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()`.

`pwmEnableChannelNotification()` разрешает вызов `callback` функций, срабатывающих при переходе канала из состояния `active` в состояние `idle`. Аргументами являются указатель на драйвер и номер канала. 
В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()` и указанный канал должен быть запущен с помощью `pwmEnableChannel()`.

`pwmDisableChannelNotification()` запрещает вызов `callback` функций, срабатывающих при переходе канала из состояния `active` в состояние `idle`. Аргументами являются указатель на драйвер и номер канала. 
В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()` и указанный канал должен быть запущен с помощью `pwmEnableChannel()`.

Так же есть функции I-класса, которые можно выполнять в lock-зонах (например, прерываниях).

  - `pwmChangePeriodI(pwm_driver, period)`
  - `pwmEnableChannelI(pwm_driver, channel, width)`
  - `pwmDisableChannelI(pwm_driver, channel)`
  - `pwmIsChannelEnabledI(pwm_driver, channel)`
  - `pwmEnablePeriodicNotificationI(pwm_driver)`
  - `pwmDisablePeriodicNotificationI(pwm_driver)`
  - `pwmEnableChannelNotificationI(pwm_driver, channel)`
  - `pwmDisableChannelNotificationI(pwm_driver, channel)`
  
Почти все они дублируют обычные функции, но есть проверка запущен ли канал.
  
## А теперь пример

Код для платы NUCLEO-F767ZI
```c
#include "ch.h"
#include "hal.h"

// Первая callback функция
void cb_fun1(PWMDriver *pwmp)
{
    (void)pwmp;
    palToggleLine(LINE_LED1);
}

// Вторая callback функция
void cb_fun2(PWMDriver *pwmp)
{
    (void)pwmp;
    palToggleLine(LINE_LED2);
}

// Структура конфигурации
static PWMConfig pwmcfg = {
  // Частота 10кГц
  .frequency = 100000,
  // Период 5000 тактов, или 0,05с
  .period = 5000,
  // Ссылка на функцию
  .callback = cb_fun1,
  .channels = {
   // Включаем первый канал в комплементарном режиме, с вызовом второй функции
   {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, cb_fun2},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  // Задаем мёртвое время 2мкс
  .bdtr = 0b11010110,
  .dier = 0
};
// Сохраняем указатель на первый драйвер в переменную
static PWMDriver *pwm = &PWMD1;

int main(void) {
    halInit();
    chSysInit();
    // Запускаем ШИМ
    pwmStart(pwm, &pwmcfg);
    // Разрешаем вызов первой функции
    pwmEnablePeriodicNotification(pwm);
    // Устанавливаем ноги первого канала первого таймера в режим ШИМ
    palSetLineMode(PAL_LINE(GPIOE, 9), PAL_MODE_ALTERNATE(1));
    palSetLineMode(PAL_LINE(GPIOE, 8), PAL_MODE_ALTERNATE(1));
    // Начинаем генерацию сигнала на ногах
    pwmEnableChannel(pwm, 0, PWM_PERCENTAGE_TO_WIDTH(pwm, 5000));
    // Разрешаем вызов второй функции
    pwmEnableChannelNotification(pwm, 0);
    uint16_t duty = 0;
    while (true) {
        // Рисуем пилообразный сигнал
        duty += 100;
        if(duty > 10000) duty = 0;
        pwmEnableChannel(pwm, 0, PWM_PERCENTAGE_TO_WIDTH(pwm, duty));
        chThdSleepMilliseconds(200);
    }
}
```

На практике не всегда вам может понадобиться комплементарный режим и `callback` функции. Для контраста, вот другой пример 

```c
static PWMDriver *pwm1Driver = &PWMD1;

PWMConfig pwm1conf = {
    .frequency = 500000,
    .period    = 10000,	 
    .callback  = NULL,
    .channels  = {
                  {.mode = PWM_OUTPUT_ACTIVE_HIGH, .callback = NULL}, // Channel 1 is working CH1 = PE9		
                  {.mode = PWM_OUTPUT_DISABLED,    .callback = NULL},
                  {.mode = PWM_OUTPUT_DISABLED,    .callback = NULL},
                  {.mode = PWM_OUTPUT_DISABLED,    .callback = NULL}
                  },
    .cr2        = 0,
    .dier       = 0
};

int main(void)
{
    chSysInit();
    halInit();

    palSetLineMode( PAL_LINE( GPIOE, 9 ),  PAL_MODE_ALTERNATE(1) );
    pwmStart( &PWMD1, &pwm1conf );
    pwmEnableChannel( &PWMD1, 0, 5000 );

    while (true);
}
```

> `palSetLineMode( PAL_LINE( GPIOE, 9 ),  PAL_MODE_ALTERNATE(1) );` - настройка пина PG9 на работу с таймером (номер функции берётся из [Datasheet](http://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=89))

> Этот пример запускает ШИМ с периодом 20 мс и скважностью 10 мс. 
