# Инструкция по работе с драйвером PWM

## Содержание <a id="content"></a>

* [Что такое PWM?](#pwm)
* [Как выбрать таймер?](#timer)
* [Запуск ШИМ](#run)
* [Кофигурация ШИМ](#config)
* [Как рассчитать частоту ШИМ?](#frequency)
* [Как рассчитать период ШИМ?](#period)
* [Как настраивать каналы ШИМ?](#cahnnels)
* [Расшифровка остальных конфигов](#registers)
* [Примеры конфигураций](#config_examples)
* [Как заполнять callback?](#callback)
* [Что же с этим всем делать?](#usage)
* [Пара примеров](#example)

## Что такое PWM? <a id="pwm"></a>

`PWM` (или же цифровая ШИМ) - это драйвер, генерирующий на ноге контроллера прямоугольный сигнал. Драйвер использует таймер, поэтому начать необходимо именно с выбора свободного таймера. Не все таймеры могут опеспечить работу ШИМ. 

[Содержание](#content)

## Как выбрать таймер? <a id="timer"></a>

Так как мы собираемся работать с таймером (на самом деле драйвера ШИМ не существует, всю работу выполняет сам таймер), стоит про [него прочитать](GPT_setup.md#gpt).

Единственное, так как теперь будем искать достаточно конкретную информацию, посмотрим [документацию](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=39) еще раз.

Оттуда получим следующую информацию:

  - `TIM1` и `TIM8` - 16-ти битные advanced таймеры с 4 комплементарными каналами;
  - `TIM2` и `TIM5` - 32-х битные таймеры с 4 каналами;
  - `TIM3` и `TIM4` - 16-ти битные таймеры с 4 каналами;
  - `TIM9` и `TIM12` - 16-ти битные таймеры с двумя каналами;
  - `TIM10`, `TIM11`, `TIM13` и `TIM14` - 16-ти битные таймеры с одним каналом.

Каждый канал таймера это какая-то нога, причем как обычно есть несколько вариантов. Смотрим [таблицу](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=89) и ищём что-нибудь вроде `TIM1_CH2`, что означает второй канал первого таймера. 

<p align="center">
<img src="pwm_pics/fig1.PNG" width=600/>
</p>

У первого и восьмого таймеров каждый канал обозначен двумая ногами, например, `TIM8_CH1` и `TIM8_CH1N`.

<p align="center">
<img src="pwm_pics/fig2.PNG" width=600/>
</p>

Это особенность **Advanced** таймеров, которая означает, что две ноги могут работать в [комплементарном режиме](http://we.easyelectronics.ru/_YS_/complementary-pwm-i-push-pull-rezhimy-na-taymere-1-kontrollerov-stm32.html#:~:text=%D0%92%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%BD%D0%BE%D0%BC%20%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5%20%D0%B2%D1%82%D0%BE%D1%80%D0%BE%D0%B9%20%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB,%D0%B8%20%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D1%8E%D1%82%20%D0%BA%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82%20%D0%B7%D0%B0%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE.). Причем первый и восьмой таймеры могут работать и в обычном режиме, смотря что установлено в конфигурации.

Выбрав нужные ноги и, соответственно, таймеры, включаем модуль в `halconf.h`, установив `HAL_USE_PWM` в состояние `TRUE`, а также нужный `STM32_PWM_USE_TIMx`. Если нужен комплeментарный режим, также включаем `STM32_PWM_USE_ADVANCED`. Если не понимаешь о чём речь - [смотри сюда](Basics.md)

[Содержание](#content)

## Запуск ШИМ <a id="run"></a>

Чтобы запустить драйвер, нужно вызвать функцию 
```c
pwmStart(&pwm_driver, &pwm_config);
```

Первый аргумент - указатель на драйвер, где имя драйвера `PWMDx`, где `x` - номер того самого подключенного в `mcuconf.h` устройства. Второй аргумент - указатель на структуру конфигурации драйвера.

Чтобы не запоминать номер таймера и не следить за правильным взятием адреса, можно положить указатель на драйвер в переменную
```c
static PWMDriver *pwm1Driver = &PWMD1;
```

Тогда запуск драйвера будет выглядеть так 
```c
pwmStart(pwm1Driver, &pwm_config);
```

[Содержание](#content)

## Кофигурация ШИМ <a id="config"></a>

Структура конфигурации выглядит следующим образом:

```c
typedef struct {
  uint32_t         frequency;             // Частота в герцах
  pwmcnt_t         period;                // Период в тактах
  pwmcallback_t    callback;              // Callback функция, если не требуется, можно установить в NULL
  PWMChannelConfig channels[PWM_CHANNELS] // Структура настройки каналов
  uint32_t         cr2                    // CONTROL_REGISTER2
  uint32_t         bdtr	                  // break and dead-time register. 
  // Используется только для advanced таймеров. 
  // Если advanced режим не включен, НЕ УКАЗЫВАЙТЕ это поле! 
  // Либо получите ошибку (что хорошо), либо вылезете за пределы памяти (очень плохо).
  uint32_t         dier                   // DMA/Interrupt enable register 
} PWMConfig;
```

[Содержание](#content)

## Как рассчитать частоту ШИМ? <a id="frequency"></a>

Напомним, что частота ограничена сверху частотой шины, а снизу глубиной предделителя. 

Причем так как предделитель может принимать только **целые значения**, частота тактирования шины должна делиться на желаемую частотау таймера **нацело**.

Если не понятно или забыли, снова обращемся к [настройке таймера](GPT_setup.md#config).

[Содержание](#content)

## Как рассчитать период ШИМ? <a id="period"></a>

Период задается в тактах и ограничен разрядностью счетчика. 

То есть если таймер 16-ти битный, нельзя поставить значение периода больше 65 536. 

Соотношение частоты и периода дает итоговую частоту генерируемого сигнала.

> Чтобы посчитать период работы ШИМ можно воспользоваться следующей формулой: PWM_period [s] = period / frequency.

То есть, если частота равна 10000 Гц, а период 100 тактов, частота генерируемого меандра будет 100 Гц. Одной и той же частоты сигнала можно добиться множеством различных конфигураций. Чем больше будет установлена частота тактирования, тем большее разрешение будет у итогового сигнала, а значит, можно будет точнее указать коэффициент заполнения (ширину импульса).

[Содержание](#content)

## Как настраивать каналы ШИМ? <a id="channels"></a>

Поле `channels` это массив структур, где каждая структура описывает работу одного канала. 

Размер массива фиксируется по максимальному количеству каналов среди всех таймеров. 

> В случае NUCLEO-F767ZI это 6 каналов на 1 и 8 таймерах (есть вариант работы трёхфазного ШИМ-генератора, независимых каналов всё ещё только 4), но для ясности кода, лучше несуществующие каналы не писать.


Структура описывает работу канала и выглядит она следующим образом:

```c
typedef struct {
  pwmmode_t         mode;           // Режим работы канала
  pwmcallback_t     callback;       // Callback функция, если не требуется, можно установить в NULL
} PWMChannelConfig;
```

Чтобы понять что писать в поля структуры, разберёмся с принципом работы ШИМ. 

В каждый момент времени, каждый канал обусловлен одним из двух состояний: `active` или `idle`. 

Состояние `active` устанавливается после начала нового периода, а состояние `idle` устанавливается после совпадения счётчика со значением, определяющим коэффициент заполениния сигнала. 

Время периода складывается из длительности состояний `active` и `idle`. При этом `active` может быть как высоким, так и низким уровнем напряжения.

<p align="center">
<img src="pwm_pics/fig3.PNG" width="600">
</p>

Таким образом, в поле `mode` можно установить три разных значения:

  - `PWM_OUTPUT_ACTIVE_HIGH` - состояние `active` соответствует высокому уровню напряжения;
  - `PWM_OUTPUT_ACTIVE_LOW` - состояние `idle` соответствует высокому напряжению;
  - `PWM_OUTPUT_DISABLED` - канал выключен.

Если используется advanced таймер, в то же поле через операцию **ИЛИ** надо указать режим комплементарной ноги:

  - `PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH`
  - `PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH`
  - `PWM_COMPLEMENTARY_OUTPUT_DISABLED`

Например, если необходимы два комплементарных канала четырёхканального таймера, поле `channels` структуры конфигурации драйвера будет выглядеть следующим образом:

```c
.channels = {
        {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
        {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
        {PWM_OUTPUT_DISABLED, NULL},
        {PWM_OUTPUT_DISABLED, NULL}
    },
```

Однако, важно помнить, что комплементарный режим означает работу в противофазе, то есть если нога `TIM1_CH1` находится в состоянии `active`, то нога `TIM1_CH1N` будет в состоянии `idle`. 

Таким образом, если для обеих ног указан режим `ACTIVE_HIGH`, первую часть периода `TIM1_CH1` будет в состоянии высокого напряжения, а `TIM1_CH1N` наоборот в состоянии низкого напряжения.

[Содержание](#content)

## Расшифровка остальных конфигов <a id="registers"></a>

Поле `cr2` - регистр таймера `CONTROL_REGISTER2`. Теоретически там можно управлять синхранизацией таймеров, но скорее всего не понадобится, так что не думая ставим 0.

Поле `bdtr` - регистр таймера `BREAK_AND_DEAD-TIME_REGISTER`. 

Регистр отвечает за две функции:
- аварийная остановка (BREAK)
- установка мёртвого времени (DEAD-TIME)

Первая функция довольно специфическая и рассмотрена тут не будет, а вот мёртвое время бывает довольно полезно. 

Мёртвое время - это пауза между изменением состояний двух комплементарных ног одного канала. То есть сначала одна нога перейдёт из высокого состояния в низкое, затем пауза и только потом вторая нога перейдёт из низкого состояния в высокое. Это необходимо в силовых мостовых схемах для учёта времени открытия и закрытия транзисторов.

За мёртвое время отвечают только 8 младших бит, причем 5-7 биты выступают в роли предделителей достаточно хитрым образом:

  - Если седьмой бит 0, то мертвое время будет равно `BDTG[6:0]*T_dts`, где `T_dts` - период счётчика мёртвого времени, который в свою очередь зависит от частоты тактирования шины и предделителя;
  - Если седьмой бит 1, а шестой 0, то мёртвое время будет равно `(64 + BDTG[5:0])*2*T_dts`;
  - Если шестой и седьмой биты 1, а пятый 0, то мёртвое время будет равно `(32 + BDTG[4:0])*8*T_dts`;
  - Если биты с пятого по седьмой единицы, то мёртвое время будет равно `(32 + BDTG[4:0])*16*T_dts`.

Предделитель счетчика задается в `CONTROL_REGISTER1`, к которому `ChibiOS` не предлагает обращаться через API, а номинальное значение равно единице, так что, пожалуй, не будем спорить.

Для наглядности, пример:

* Частота шины на первом таймере при номинальном предделителе - 216Мгц, то есть период такта составляет 4,63нс.
* Если установить в поле `bdtr` значение `0b11111111` это будет означать `(32 + 31)*16*4,63*10^(-9)` или же ~4,3мкс.
* Если же необходимо добится паузы в 2мкс, можно пойти обратным путём: `2000/4,63/8=54` (желаемые 2мкс делим на период такта и делим на предделитель 8), 54=32+22, то есть в  `bdtr ` надо положить `0b11010110`.

Последнее поле `dier` - `DMA_INTERRUPT_REGISTER`, отвечает за capture/compare прерывания и прямой доступ к памяти, и тоже скорее всего не понядобится, так что оставляем ноль.

[Содержание](#content)

## Примеры конфигураций <a id="config_examples"></a>

В итоге если комплементарный режим не нужен, структура конфигурации выглядит как-то так:
```c
static PWMConfig pwmcfg = {
  .frequency = 500000,
  .period = 10000,
  .callback = NULL,
  .channels = {
   {PWM_OUTPUT_ACTIVE_HIGH, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  .dier = 0
};
```

Если комплиментарный режим нужен, то становится вот так:
```c
static PWMConfig pwmcfg = {
  .frequency = 500000,
  .period = 10000,
  .callback = NULL,
  .channels = {
   {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  .bdtr = 0b11010110,
  .dier = 0
};
```

## Как заполнять callback? <a id="callback"></a>

Поле `callback` содержит указатель на функцию, которая будет вызываться в момент перехода канала из состояния `active` в состояние `idle`.

Если хочется, чтобы ШИМ дёргал какую-нибудь функцию, необходимо указать ссылку на эту функцию в поле `callback`. Функция не может ничего возвращать, и должна принимать один аргумент - указатель на драйвер. 
То есть выглядеть она может только так:

```c
void pwmcb_fun(PWMDriver *pwmp)
{
    (void)pwmp; // Это не обязательно, просто чтобы не было ворнингов о неиспользуемой переменной
    ...
    some code
    ...
}
```

Просто указать функцию недостаточно, надо ещё разрешить прерывания, но об этом чуть ниже.

[Содержание](#content)

## Что же с этим всем делать? <a id="usage"></a>

ChibiOS предлагает следующие функции для работы с модулем:

  - `pwmStart(pwm_driver, pwm_config)`
  - `pwmStop(pwm_driver)`
  - `pwmChangePeriod(pwm_driver, period)`
  - `pwmEnableChannel(pwm_driver, channel, width)`
  - `pwmDisableChannel(pwm_driver, channel)`
  - `pwmEnablePeriodicNotification(pwm_driver)`
  - `pwmDisablePeriodicNotification(pwm_driver)`
  - `pwmEnableChannelNotification(pwm_driver, channel)`
  - `pwmDisableChannelNotification(pwm_driver, channel)`

С функциями `pwmStart()` и `pwmStop()`, скорее всего, всё понятно.

`pwmChangePeriod()` позволяет изменить период сигнала во время работы драйвера. Аргументами являются указатель на драйвер и желаемый период в тактах. Частоту тактирования на ходу изменить нельзя, если возникает такая необходимость, надо переопределить структуру конфигурации и перезапустить драйвер.

`pwmEnableChannel()` - начинает генерацию ШИМ сигнала на ноге. Аргументы - указатель на драйвер, номер канала (нумерация начинается с нуля), и ширина импульса в тактах. Для того, чтобы при установке коэффициента заполнения сигнала не зависеть от выбранного периода, есть следующие дефайны:

  - `PWM_FRACTION_TO_WIDTH(driver, denominator, numenator)` - расчёт количества тактов по соотношению в виде числитель/знаменатель. 
  - `PWM_DEGREES_TO_WIDTH(driver, degrees)` - расчёт количества тактов по значению фазы в градусах. Значение задаётся в сотых градуса, так что допустимый диапазон значений [0 36000].
  - `PWM_PERCENTAGE_TO_WIDTH(driver, percentage)` - расчёт количества тактов из процентов. Значение задаётся в сотых процента, так что допустимый диапазон значений [0 10000].

Тут необходимо держать в голове, что как бы точно не была посчитана желаемая длительность импульса, это все еще `int`, то есть в любом случае будет округление. Расчитывайте разрешение сигнала исходя из решаемой задачи.

Изменение длительности импульса обеспечивается повторным вызовом функции `pwmEnableChannel()` с новым значением `width`.

`pwmDisableChannel()` выключает канал, то есть переводит ногу в `idle` состояние и запрещает вызов `callback` функции.

`pwmEnablePeriodicNotification()` разрешает вызов `callback` функций, срабатывающих каждый период. Аргументом является указатель на драйвер. В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()`.

`pwmDisablePeriodicNotification()` запрещает вызов `callback` функций, срабатывающих каждый период. Аргументом является указатель на драйвер. В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()`.

`pwmEnableChannelNotification()` разрешает вызов `callback` функций, срабатывающих при переходе канала из состояния `active` в состояние `idle`. Аргументами являются указатель на драйвер и номер канала. 
В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()` и указанный канал должен быть запущен с помощью `pwmEnableChannel()`.

`pwmDisableChannelNotification()` запрещает вызов `callback` функций, срабатывающих при переходе канала из состояния `active` в состояние `idle`. Аргументами являются указатель на драйвер и номер канала. 
В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()` и указанный канал должен быть запущен с помощью `pwmEnableChannel()`.

Так же есть функции I-класса, которые можно выполнять в прерываниях (например, callback функциях).

  - `pwmChangePeriodI(pwm_driver, period)`
  - `pwmEnableChannelI(pwm_driver, channel, width)`
  - `pwmDisableChannelI(pwm_driver, channel)`
  - `pwmIsChannelEnabledI(pwm_driver, channel)`
  - `pwmEnablePeriodicNotificationI(pwm_driver)`
  - `pwmDisablePeriodicNotificationI(pwm_driver)`
  - `pwmEnableChannelNotificationI(pwm_driver, channel)`
  - `pwmDisableChannelNotificationI(pwm_driver, channel)`
  
Почти все они дублируют обычные функции, но есть проверка запущен ли канал.

[Содержание](#content)

## А теперь примеры <a id="example"></a>

Код для платы NUCLEO-F767ZI

Включим ШИМ на одной ноге с частотой 50 герц и коэффициентом заполнения 50%. Проект можно найти [тут](../HAL_examples/PWM/simple_test).

<details>
<summary>Код main.c под спойлером</summary>

```c
#include "ch.h"
#include "hal.h"

// Положим указатель на драйвер в переменную
static PWMDriver *pwm1Driver = &PWMD1;

PWMConfig pwm1conf = {
    // Укажем частоту 500кГц (предделитель равен 436, так что значение допустимое)
    .frequency = 500000,
    // Период равен 10000 тактам таймера, то есть 0,02 секунды
    .period    = 10000,	 
    // Не будем использовать прерывание по окончанию периода
    .callback  = NULL,
    // Настроим только первый кнал в состояние ACTIVE_HIGH и так же не будем использовать прерывание
    .channels  = {
                  {.mode = PWM_OUTPUT_ACTIVE_HIGH, .callback = NULL},
                  {.mode = PWM_OUTPUT_DISABLED,    .callback = NULL},
                  {.mode = PWM_OUTPUT_DISABLED,    .callback = NULL},
                  {.mode = PWM_OUTPUT_DISABLED,    .callback = NULL}
                  },
    // Регистры оставим в покое. Обратите внимание, advanced функции таймера выключены, поэтому регистра bdtr нет
    .cr2        = 0,
    .dier       = 0
};

int main(void)
{
    chSysInit();
    halInit();
    // Переведем ногу E9 в альтернативный режим 1, так как имнно он является первым каналом первого таймера
    palSetLineMode( PAL_LINE( GPIOE, 9 ),  PAL_MODE_ALTERNATE(1) );
    // Запустим модуль в работу
    pwmStart( &PWMD1, &pwm1conf );
    // Запустим канал с коэффициентом заполнения 50% (здесь третий аргумент это количество тактов, 5000 / 10000 = 0,5) 
    pwmEnableChannel( &PWMD1, 0, 5000 );

    while (true);
}
```

</details>

Так же рассмотрим вариант с комплиментарным режимом и поморгаем лампочками из прерываний. Проект можно найти [тут](../HAL_examples/PWM/complementary_test).

<details>
<summary>Код main.c под спойлером</summary>

```c
#include "ch.h"
#include "hal.h"

// Первая callback функция
void cb_fun1(PWMDriver *pwmp)
{
    (void)pwmp;
    palToggleLine(LINE_LED1);
}

// Вторая callback функция
void cb_fun2(PWMDriver *pwmp)
{
    (void)pwmp;
    palToggleLine(LINE_LED2);
}

// Структура конфигурации
static PWMConfig pwmcfg = {
  // Частота 10кГц
  .frequency = 100000,
  // Период 5000 тактов, или 0,05с
  .period = 5000,
  // Ссылка на функцию
  .callback = cb_fun1,
  .channels = {
   // Включаем первый канал в комплементарном режиме, с вызовом второй функции
   {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, cb_fun2},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  // Задаем мёртвое время 2мкс
  .bdtr = 0b11010110,
  .dier = 0
};
// Сохраняем указатель на первый драйвер в переменную
static PWMDriver *pwm = &PWMD1;

int main(void) {
    halInit();
    chSysInit();
    // Запускаем ШИМ
    pwmStart(pwm, &pwmcfg);
    // Разрешаем вызов первой функции
    pwmEnablePeriodicNotification(pwm);
    // Устанавливаем ноги первого канала первого таймера в режим ШИМ
    palSetLineMode(PAL_LINE(GPIOE, 9), PAL_MODE_ALTERNATE(1));
    palSetLineMode(PAL_LINE(GPIOE, 8), PAL_MODE_ALTERNATE(1));
    // Начинаем генерацию сигнала на ногах
    pwmEnableChannel(pwm, 0, PWM_PERCENTAGE_TO_WIDTH(pwm, 5000));
    // Разрешаем вызов второй функции
    pwmEnableChannelNotification(pwm, 0);
    uint16_t duty = 0;
    while (true) {
        // Рисуем пилообразный сигнал
        duty += 100;
        if(duty > 10000) duty = 0;
        pwmEnableChannel(pwm, 0, PWM_PERCENTAGE_TO_WIDTH(pwm, duty));
        chThdSleepMilliseconds(200);
    }
}
```

</details>

[Содержание](#content)
