# Инструкция по работе с драйвером PWM

`PWM` (или же цифровая ШИМ) - драйвер генерирующий на ножке контроллера прямоугольный сигнал. Драйвер использует таймер, поэтому начать необходимо именно с выбора свободного таймера. Не все таймеры могут опеспечить работу ШИМ. 
Чтобы понять с какими работать можно посмотрим файл `mcuconf.h`, раздел `PWM driver system settings`. В случае STM32F767ZI предлагается выбрать из таймеров 1-5 и 8-17. Однако, если выбрать, например, 16, при сборке получим ошибку
"TIM16 not present in the selected device". Так что все-таки идем читать [документацию](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=39).
Из описания можно получить следующую информацию:

  - `TIM1` и `TIM8` - 16-ти битные advanced таймеры с четыремя комплиментарными каналами;
  - `TIM2` и `TIM5` - 32-х битные таймеры с четыремя каналами;
  - `TIM3` и `TIM4` - 16-ти битные таймеры с четыремя каналами;
  - `TIM9` и `TIM12` - 16-ти битные таймеры с двумя каналами;
  - `TIM10`, `TIM11`, `TIM13` и `TIM14` - 16-ти битные таймеры с одним каналом.

Также желаемый таймер должен быть никем не занят. Тут стоит обратить внимание, что как минимум один таймер занят под операционную систему. 
Какой именно смотрим в mcuconf в дефайне `STM32_ST_USE_TIMER`, в моем случае это второй таймер. Так как по умолчанию `ChibiOS` хочет использовать 32-х битный таймер, 
поменять можно только на пятый, но если готовы пожертвовать разрешением можно поменять `CH_CFG_ST_RESOLUTION` в `chconf.h` с 32 на 16 и использовать другой таймер, 
но скорее всего это лишнее.

Каждый канал таймера это какая-то нога, причем как обычно есть несколько вариантов. Смотрим [таблицу](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=89)
и ищем что-нибудь вроде `TIM1_ch2`, что означает второй канал первого таймера. У первого и восьмого таймеров каждый канал обозначен двумая ногами, например, `TIM8_ch1` и `TIM8_ch1n`. 
Это особенность Advanced таймеров и означает, что две ноги могут работать в комплиментарном режиме. Причем первый и восьмой таймеры могут работать и в обычном режиме, смотря что установлено в конфигурации.

Выбрав нужные ноги и, соответственно, таймеры, включаем модуль в `halconf.h` установив `HAL_USE_PWM` в состояние `TRUE`, а также нужный `STM32_PWM_USE_TIMx`. Если нужен комплиментарный режим, также включаем `STM32_PWM_USE_ADVANCED`.

Как обычно, чтобы запустить драйвер в работу вызываем `pwmStart(\*pwm_driver, \*pwm_config)`.

Имя драйвера PWMDx зависит от выбранного таймера. Чтобы не помнить каждый раз про взятие адреса, можно положить указатель на драйвер в переменную:

```c
static PWMDriver *pwm1 = &PWMD1;
```

Структура конфигурации выглядит следующим образом:

```c
typedef struct {
  uint32_t         frequency;       // Частота в герцах
  pwmcnt_t         period;          // Период в тактах
  pwmcallback_t    callback;        // Callback функция, если не требуется, можно установить в NULL
  PWMChannelConfig channels[PWM_CHANNELS] // Структура настройки каналов
  uint32_t         cr2              // CONTROL_REGISTER2
  uint32_t         bdtr	            // break and dead-time register. Используется только для advanced таймеров. Если advanced режим не включен, НЕ УКАЗЫВАЙТЕ это поле! Либо получите ошибку (что хорошо), либо вылезете за пределы памяти (очень плохо).
  uint32_t         dier             // DMA/Interrupt enable register 
} PWMConfig;
```

Частота ограничена сверху частотой шины, а снизу глубиной предделителя. Причем так как предделитель может принимать только целые значение, частота тактирования шины должна делиться на желаемую частотау таймера нацело. 
Таймеры могут висеть на шинах `APB1` или `APB2`. На какой именно шине висит каждый таймер можно посмотреть [тут](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=20).
На картинке видно, что таймеры 1, 8, 9, 10, 11 относятся к `APB2`, а таймеры 2, 3, 4, 5, 12, 13, 14 к APB1. Частота шины вычисляется, как частота процессора, деленная на предделитель. 
Значение предделителя можно подглядеть в `mcuconf.h`. `STM32_PPRE1` является предделителем для `APB1`, а `STM32_PPRE2` для `APB2`. Однако, экспериментально определено, что на самом деле частота таймера может превышать 
частоту ШИМ в два раза (вероятнее всего, триггером для таймера являются и нарастающий и падающий фронты). То есть для первого таймера STM32F767ZI получается, что частота процессора 216МГц, предделитель `APB2`
номинально установлен в двойку, а значит максимальная частота 216МГц (216 / 2 \* 2), а минимальная - 3295,898Гц (216000000 / 2^16). Но, так как поле в структуре также должно быть целым, выходит,
что минимальное допустимое значение - 3375 (216000000 / 64000).

Период задается в тактах и ограничен разрядностью счетчика. То есть если таймер 16-ти битный, нельзя поставить значение периода больше 65 536. Соотношение частоты и периода дает итоговую частоту генерируемого сигнала.
То есть, если частота 10000 Гц, а период 100 тактов, частота генерируемого меандра будет 100 Гц. Одной и той же частоты сигнала можно добиться множеством различных конфигураций. Чем больше будет установлена частота тактирования,
тем большее разрешение будет у итогового сигнала, а значит, можно будет точнее указать коэффициент заполнения (ширину импульса).

В поле `callback` можно указать функцию, которая будет вызываться каждый период ШИМ, подробнее разберем ниже.

Поле `channels` это массив структур, где каждая структура описывает работу одного канала. Размер массива фиксируется по максимальному количеству каналов среди всех таймеров. В случае NUCLEO-F767ZI это 6 каналов на 1 и 8 таймерах
(есть вариант работы трехфазного ШИМ-генератора. Независимых каналов все еще только 4), но для ясности кода, лучше несуществующие каналы не писать.
Структура описывает работу канала и выглядит она следующим образом:

```c
typedef struct {
  pwmmode_t         mode;           // Режим работы канала
  pwmcallback_t     callback;       // Callback функция, если не требуется, можно установить в NULL
} PWMChannelConfig;
```

Чтобы понять что писать в поля структуры, разберемся с принципом работы ШИМ. В каждый момент времени, каждый канал обусловлен одним из двух состояний: `active` или `idle`. 
Состояние `active` устанавливается после начала нового периода, а состояние `idle` устанавливается после совпадения счетчика со значением, определяющим коэффициент заполениния сигнала. 
Таким образом, время периода складывается из длительности состояний `active` и `idle`. При этом active может быть как высоким, так и низким уровнем напряжения.

<p align="center">
<img src="pwm_pics/fig6.png" width="500">
</p>

Таким образом, в поле mode можно установить три разных значения:

  - `PWM_OUTPUT_ACTIVE_HIGH` - состояние active соответствует высокому уровню напряжения;
  - `PWM_OUTPUT_ACTIVE_LOW` - состояние idle соответствует высокому напряжению;
  - `PWM_OUTPUT_DISABLED` - канал выключен.

Если используется advanced таймер, в то же поле через операцию ИЛИ надо указать режим комплиментарной ноги:

  - `PWM_OUTPUT_ACTIVE_HIGH`
  - `PWM_OUTPUT_ACTIVE_LOW`
  - `PWM_OUTPUT_DISABLED`

Однако, важно помнить, что комплиментарный режим означает работу в противофазе, то есть если нога `TIM1_CH1` находится в состоянии `active`, то нога `TIM1_CH1N` будет в состоянии `idle`. 
Таким образом, если для обеих ног указан режим `ACTIVE_HIGH`, первую часть периода `TIM1_CH1` будет в состоянии высокого напряжения, а `TIM1_CH1N` наоборот в состоянии низкого напряжения.

Поле `callback` содержит указатель на функцию, которая будет вызываться в момент перехода канала из состоянии `active` в состояние `idle`.

Например, если необходимы два комплиментарных канала четырехканального таймера, поле `channels` структуры конфигурации драйвера будет выглядеть следующим образом:

```c
.channels = {
        {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
        {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
        {PWM_OUTPUT_DISABLED, NULL},
        {PWM_OUTPUT_DISABLED, NULL}
    },
```

Поле `cr2` - регистр таймера `CONTROL_REGISTER2`. Теоретически там можно управлять синхранизацие таймеров, но скорее всего не понадобится, так что не думая ставим 0.

Поле `bdtr` - регистр таймера `BREAK_AND_DEAD-TIME_REGISTER`. Регистр отвечает за две функции - аварийной остановки (BREAK) и установку мертвого времени (DEAD-TIME). Первая функция довольно специфическая и рассмотрена тут не будет,
а вот мертвое время бывает довольно полезно. Мертвое время - пауза между изменением состояний двух комплиментарных ног одного канала. То есть сначала одна нога перейдет из высокого состояния в низкое, затем пауза и только потом
вторая нога перейдет из низкого состояния в высокое. Это необходимо в силовых мостовых схемах для учета времени открытия и закрытия транзисторов.
За мертвое время отвечают только 8 младших бит, причем 5-7 биты выступают в роли предделителей достаточно хитрым образом:

  - Если седьмой бит 0, то мертвое время будет равно `BDTG[6:0]*T_dts`, где T_dts - период счетчика мертвого времени, который в свою очередь зависит от частоты тактирования шины и предделителя;
  - Если седьмой бит 1, а шестой 0, то мертвое время будет равно `(64 + BDTG[5:0])*2*T_dts`;
  - Если шестой и седьмой биты 1, а пятый 0, то мертвое время будет равно `(32 + BDTG[4:0])*8*T_dts`;
  - Если биты с пятого по седьмой единицы, то мертвое время будет равно `(32 + BDTG[4:0])*16*T_dts`.

Предделитель счетчика задается в `CONTROL_REGISTER1`, к которому `CibiOS` не предлагает обращаться через API, а номинальное значение равно единице, так что, пожалуй, не будем спорить.
Для наглядности, пример:

Частота шины на первом таймере при номинальном предделителе - 216Мгц, то есть период такта составляет 4,63нс.
Если установить в поле `bdtr` значение 0b11111111 это будет означать `(32 + 31)*16*4,63*10^(-9)` или же ~4,3мкс.
Если же необходимо добится паузы в 2мкс, можно пойти обратным путем: `2000/4,63/8=54` (желаемые 2мкс делим на период такта и делим на предделитель 8), 54=32+22, то есть в bdtr надо положить `0b11010110`.

Последнее поле `dier` - `DMA_INTERRUPT_REGISTER`, отвечает за capture/compare прерывания и прямой доступ к памяти, и тоже скорее всего не понядобятся, так что оставляем ноль.

В итоге если комплиментарный режим не нужен, структура конфигурации выглядит как-то так:
```c
static PWMConfig pwmcfg = {
  .frequency = 500000,
  .period = 10000,
  .callback = NULL,
  .channels = {
   {PWM_OUTPUT_ACTIVE_HIGH, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  .dier = 0
};
```

Если комплиментарный режим нужен, то становится вот так:
```c
static PWMConfig pwmcfg = {
  .frequency = 500000,
  .period = 10000,
  .callback = NULL,
  .channels = {
   {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  .bdtr = 0b11010110,
  .dier = 0
};
```

Если хочется, чтобы ШИМ дергал какию-нибудь функцию, необходимо указать ссылку на эту функцию в поле `callback`. Функция не может ничего возвращать, и должна принимать один аргумент - указатель на драйвер. 
То есть выглядеть она может только так:

```c
void pwmcb_fun(PWMDriver *pwmp)
{
    (void)pwmp; // Это не обязательно, просто чтобы не было ворнингов о неиспользуемой переменной
    ...
    some code
    ...
}
```

Просто указать функцию недостаточно, надо еще разрешить прерывания, но об этом чуть ниже.

# Что же с этим всем делать

ChibiOS предлагает следующие функции для работы с модулем:

  - `pwmStart(pwm_driver, pwm_config)`
  - `pwmStop(pwm_driver)`
  - `pwmChangePeriod(pwm_driver, period)`
  - `pwmEnableChannel(pwm_driver, channel, width)`
  - `pwmDisableChannel(pwm_driver, channel)`
  - `pwmEnablePeriodicNotification(pwm_driver)`
  - `pwmDisablePeriodicNotification(pwm_driver)`
  - `pwmEnableChannelNotification(pwm_driver, channel)`
  - `pwmDisableChannelNotification(pwm_driver, channel)`

С функциями `pwmStart()` и `pwmStop()`, скорее всего, все понятно.

`pwmChangePeriod()` позволяет изменить период сигнала во время работы драйвера. Аргументами являются указатель на драйвер и желаемый период в тактах. Частоту тактирования на ходу изменить нельзя, если возникает такая необходимость, 
надо переопределить структуру конфигурации и перезапустить драйвер.

`pwmEnableChannel()` начинает генерацию ШИМ сигнала на ноге. Аргументы - указатель на драйвер, номер канала (нумерация начинается с нуля), и ширина импульса в тактах. Для того, чтобы при установке коэффициента заполнения сигнала 
не зависеть от выбранного периода, есть следующие дефайны:

  - `PWM_FRACTION_TO_WIDTH(driver, denominator, numenator)` - расчет количества тактов по соотношению в виде числитель/знаменатель. 
  - `PWM_DEGREES_TO_WIDTH(driver, degrees)` - расчет количества тактов по значению фазы в градусах. Значение задается в сотых градуса, так что допустимый диапазон значений [0 36000].
  - `PWM_PERCENTAGE_TO_WIDTH(driver, percentage)` - расчет количества тактов из процентов. Значение задается в сотых процента, так что допустимы диапазон значений [0 10000].

Тут необходимо держать в голове, что как бы точно не была посчитана желаемая длительность импульса, это все еще `int`, то есть в любом случае будет округление. Расчитывайте разрешение сигнала исходя из решаемой задачи.

Изменение длительности импульса обеспечтваеься повторным вызовом функции `pwmEnableChannel()` с новым значением `width`.

`pwmDisableChannel()` выключает канал, то есть переводит ногу в `idle` стате и запрещает вызов callback функции.

`pwmEnablePeriodicNotification()` разрешает вызов `callback` функций, срабатывающих каждый период. Аргументом является указатель на драйвер. В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()`.

`pwmDisablePeriodicNotification()` запрещает вызов `callback` функций, срабатывающих каждый период. Аргументом является указатель на драйвер. В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()`.

`pwmEnableChannelNotification()` разрешает вызов callback функций, срабатывающих при переходе канала из состояния `active` в состояние `idle`. Аргументами являются указатель на драйвер и номер канала. 
В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()` и указанный канал должен быть запущен с помощью `pwmEnableChannel()`.

`pwmDisableChannelNotification()` запрещает вызов `callback` функций, срабатывающих при переходе канала из состояния `active` в состояние `idle`. Аргументами являются указатель на драйвер и номер канала. 
В момент вызова этой функции, модуль уже должен быть запущен с помощью `pwmStart()` и указанный канал должен быть запущен с помощью `pwmEnableChannel()`.

Так же есть функции I-класса, которые можно выполнять в lock-зонах (например, прерываниях).

  - `pwmChangePeriodI(pwm_driver, period)`
  - `pwmEnableChannelI(pwm_driver, channel, width)`
  - `pwmDisableChannelI(pwm_driver, channel)`
  - `pwmIsChannelEnabledI(pwm_driver, channel)`
  - `pwmEnablePeriodicNotificationI(pwm_driver)`
  - `pwmDisablePeriodicNotificationI(pwm_driver)`
  - `pwmEnableChannelNotificationI(pwm_driver, channel)`
  - `pwmDisableChannelNotificationI(pwm_driver, channel)`
  
Почти все они дублируют обычные функции, но есть проверка запущен ли канал.
  

## А теперь пример

Код для платы NUCLEO-F767ZI
```c
#include "ch.h"
#include "hal.h"

// Первая callback функция
void cb_fun1(PWMDriver *pwmp)
{
    (void)pwmp;
    palToggleLine(LINE_LED1);
}

// Вторая callback функция
void cb_fun2(PWMDriver *pwmp)
{
    (void)pwmp;
    palToggleLine(LINE_LED2);
}

// Структура конфигурации
static PWMConfig pwmcfg = {
  // Частота 10кГц
  .frequency = 100000,
  // Период 5000 тактов, или 0,05с
  .period = 5000,
  // Ссылка на функцию
  .callback = cb_fun1,
  .channels = {
   // Включаем первый канал в комплиментарном режиме, с вызовом второй функции
   {PWM_OUTPUT_ACTIVE_HIGH | PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH, cb_fun2},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL},
   {PWM_OUTPUT_DISABLED, NULL}
  },
  .cr2 = 0,
  // Задаем мертвое время 2мкс
  .bdtr = 0b11010110,
  .dier = 0
};
// Сохраняем указатель на первый драйвер в переменную
static PWMDriver *pwm = &PWMD1;

int main(void) {
    halInit();
    chSysInit();
    // Запускаем ШИМ
    pwmStart(pwm, &pwmcfg);
    // Разрешаем вызов первой функции
    pwmEnablePeriodicNotification(pwm);
    // Устанавливаем ноги первого канала первого таймера в режим ШИМ
    palSetLineMode(PAL_LINE(GPIOE, 9), PAL_MODE_ALTERNATE(1));
    palSetLineMode(PAL_LINE(GPIOE, 8), PAL_MODE_ALTERNATE(1));
    // Начинаем генерацию сигнала на ногах
    pwmEnableChannel(pwm, 0, PWM_PERCENTAGE_TO_WIDTH(pwm, 5000));
    // Разрешаем вызов второй функции
    pwmEnableChannelNotification(pwm, 0);
    uint16_t duty = 0;
    while (true) {
        // Рисуем пилообразный сигнал
        duty += 100;
        if(duty > 10000) duty = 0;
        pwmEnableChannel(pwm, 0, PWM_PERCENTAGE_TO_WIDTH(pwm, duty));
        chThdSleepMilliseconds(200);
    }
}
```
