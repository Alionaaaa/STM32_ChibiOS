# Инструкция по работе с драйвером ADC

**Здесь рассмотрена вторая версия драйвера, которая используется на контроллерах серии F4 и F7. Всего версий 5, скорее всего позже здесь будут описаны отличия разных версий**

## Что такое ADC?

`ADC (Analog-digital convertion)` - аналого-цифровое преобразование. Модуль, который позволяет измерить напряжение на ноге контроллера и представить его в виде двоичного числа.

Для того чтобы выбрать ногу, смотрим [табличку pin and ball definitions](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=66) (*Разумеется в даташите на свой контроллер!*).
Интересует последний столбец `Additional functions`. Если там написано `ADCk_INn`, значит эта нога висит на n-ом канале k-ого модуля АЦП. Про канал разберем чуть ниже, а номер модуля нужен для того, чтобы знать что включить.

<p align="center">
<img src="adc_pics/fig1.PNG">
</p>

Сразу стоит обратить внимание, что на одной ноге могут быть несколько модулей АЦП, использовать их одновременно незачем, но главное и не получится, так что будьте внимательны!

Так же есть внутренние каналы, один на опорное напряжение `ADC_CHANNEL_VREFINT`, один на датчик температуры `ADC_CHANNEL_SENSOR` и один канал на батарейку (если питание не от источника) `ADC_CHANNEL_VBAT`. Эти каналы доступны только на `ADC1`.

Для того чтобы включить драйвер устанавливаем `HAL_USE_ADC` из `halconf.h` в состояние `TRUE` и аналогично включаем выбранный модуль в `mcuconf.h`, например `STM32_ADC_USE_ADC1`. Если не понимаешь о чём речь - [смотри сюда](Basics.md).

Также в `halconf.h` могут заинтересовать два дефайна `ADC_USE_WAIT` и `ADC_USE_MUTUAL_EXCLUSION`, зачем они чуть ниже.

Дополнительно, надо перевести выбранную ногу в состояние `PAL_MODE_ANALOG_INPUT`, подробнее написано [тут](PAL_setup.md).

## Запуск АЦП

Как и с другими модулями, запуск происходит с помощью функции 

```c
adcStart(&adc_driver, &adc_config);
``` 

Первый аргумент - указатель на драйвер, где имя драйвера `ADCDx`, где `x` - номер того самого подключённого в `mcuconf.h` устройства. Второй аргумент - указатель на структуру конфигурации драйвера.

Может возникнуть желание положить указатель в переменную, чтобы не вспоминать каждый раз про операнд взятия адреса, для этого существует тип `ADCDriver`. Например,
```c
static ADCDriver *adc1 = &ADCD1;
```

Тогда запуск `adc` будет такой 
```c
adcStart(adc1, &adc_config);
``` 

## Конфигурация АЦП

Структура конфигурации выглядит следующим образом:

```c
typedef struct {
    uint32_t        dummy;
} ADCConfig;
```

Видим, что это просто заглушка и очень радуемся, ведь если нечего настраивать, значит все просто! Ведь так? (спойлер: НЕТ!)

Таким образом, в `adcStart()` вторым аргументом можно передать любой мусор, но можно и `NULL`.

## В чем подвох?

На самом деле структура конфигурации все-таки есть, но работает она несколько иначе. Выглядит она так:

```c 
typedef struct {
    bool                      circular;
	adc_channels_num_t        num_channels;
	adccallback_t             end_cb;
	adcerrorcallback_t        error_cb;
	// Ниже необязательные (но очень важные) поля
	uint32_t                  cr1;
	uint32_t                  cr2;
	uint32_t                  smpr1;
	uint32_t                  smpr2;
	uint16_t                  htr;
	uint16_t                  ltr;
	uint32_t                  sqr1;
	uint32_t                  sqr2;
	uint32_t                  sqr3;
} ADCConversionGroup;
```

Прежде чем начать описывать поля структуры, несколько слов о работе драйвера в принципе. `ST` рассматривает работу каналов АЦП в двух вариантах: `Regular` и `Injected`. Главное отличие, в случае `Regular` на все возможные каналы есть всего один регистр для данных и каждое измерение затирает предыдущий результат в то время как `Injected` каналы объединяются в группы по 4 и имеют более высокий приоритет (то есть если во время работы обычных каналов запустить преобразовыние инжектированной группы, обычным каналам придется подождать) и у них есть 4 регистра под каждый канал. Так как эта функция специфична для платформы, в `ChibiOS` нет API для ее работы, так что все поля регистров касательно `Injected` каналов смело игнорируем. Из обычных каналов надо успевать забирать данные с помощью DMA запросов, но эту задачу `ChibiOS` берет на себя.

Обычные каналы можно объединять в обычные группы и одновременно (ну, почти) производить измерения на разных ногах. Причем `ChibiOS` позволяет собирать последовательности данных. Это может быть полезно при обработке аналоговых сигналов, например аудио. В случае множественных измерений необходимо объяснить системе, кто решает когда начинать преобразование. Это можно оставить на операционку, либо запускать преобразования по таймеру или внешнему тактированию.

Несмотря на то что преобразование для группы как будто одновременное, на самом деле оно вполне себе последовательное. Для каждого канала указывается время сэмплирования в тактах (один такт АЦП соответствует частоте шины с учетом предделителя, определенного с помощью `STM32_ADC_ADCPRE` в `mcuconf.h`) во время которого происходит заряд конденсаторов и по одному такту на на каждый бит разрешения АЦП и еще пол такта во имя науки (на самом деле что-то с дробными значениями и синхронизацией). На эту информацию можно забить, если только действительно не соберётесь работать с высокочастотными сигналами.

`ChibiOS` предлагает работать в синхронном или асинхронном режиме. Синхронный режим означает, что функция будет блокировать поток до окончания своей работы, что удобно для однократного измерения. Асинхронный в свою очередь означает, что функция инициирует измерение и поток идет дальше. В этом случае узнать об окончании преобразования можно с помощью прерываний.

Но вернёмся к структуре.

Поле `circular` отвечает за непрерывный режим работы. Если установим `TRUE`, по заполнению всего буфера буфер начнет заполняться заново. В противном случае после одного полного преобразования АЦП переходит в режим ожидания. Не стоит использовать в синхронном режиме, так как придется что-то делать чтобы разорвать вечный цикл измерений.

`num_channels` указывает на количество каналов (ног) на которых надо производить измерения.

В `end_cb` указываем имя функции, которая будет вызываться при окончании измерения. Если это не нужно, можем написать `NULL`. Если нужно, то функция не должна ничего возвращать, а принимать должна указатель на драйвер АЦП. То есть выглядеть может только так:

```c 
void adcendcbfun(ADCDriver* adcp)
{
    (void)adcp;  // Если не хотим ничего делать с драйвером, убираем ворнинг о неиспользуемой переменной
	...
	do something
	...
}
```

В случае непрерывной работы и глубине измерения большей чем единийа, функция вызовется дважды. Подробнее чуть ниже.

`error_cb` это почти то же самое, но функцию будут дергать в случае ошибки. Функция так же ничего не возвращает, а принимает указатель на драйвер ацп и ошибку (тип `adcerror_t`). Если не нужна, ставим `NULL`.

```c 
void adcendcbfun(ADCDriver* adcp, adcerror_t err)
{
    (void)adcp;  // Если не хотим ничего делать с драйвером, убираем ворнинг о неиспользуемой переменной
	(void)err;   // Если не хотим ничего делать с ошибкой, убираем ворнинг о неиспользуемой переменной
	...
	do something
	...
}
```

Ошибка может принять три разных значения:

    - `ADC_ERR_DMAFAILURE` - что-то не так с `DMA` запросами. Например, повторный запуск преобразования до окончания предыдущего.
    - `ADC_ERR_OVERFLOW` - вызвать такую проблему пока не удалось.
    - `ADC_ERR_WATCHDOG` - сработал "сторожевой пёс", про это ниже.

Так же в документации `ChibiOS` пишут не очень полагаться на эти ошибки, так как это очень сильно завязано на конкретную платформу.

Дальше идут поля, определяющие значения соответствующих регистров. Что в эти регистры можно класть смотрим в [RM](https://www.st.com/content/ccc/resource/technical/document/reference_manual/group0/96/8b/0d/ec/16/22/43/71/DM00224583/files/DM00224583.pdf/jcr:content/translations/en.DM00224583.pdf#page469) **разумеется на свой контроллер! Ниже все написано для STM32F767ZI.**.

Для более удобного заполнения регистров есть набор дефайнов, определяющих каждое поле регистров. Например для `CONTROL REGISTER1` можно задать разрядность измерения указав нужное значение в поле `RES`. И в заголовочном можно найти дефайны `ADC_CR1_RES_0` и `ADC_CR1_RES_1` определяющие единицы сдвинутые на нужное число бит.

Разберем, что же в этих регситрах есть интересного.

`CR1`:

Поле `RES` позволяет выбрать разрешение преобразования. В случае `STM32F767ZI` выбор между 6, 8, 10 и 12 битами. В `ChibiOS` данные кладутся в `uint16_t`, так что любой вариант работает.

`AWDEN` включает `watchdog` систему, что позволяет ловить недопустимые значения напряжения и инициировать ошибку.

`AWDSGL` выбирает будет ли сторожевой пёс смотреть на лдин какой-то конктретный канал или на все сразу.

`AWDIE` разрешает псу делать прерывания.

`AWDCH[4:0]` выбирает на какой канал смотреть псу, если не указали смотреть на все. Задается число от 0 до 18.

`CR2`:

`SWSTART` запускает преобразование силами `ChibiOS`. Вообще устанавливать надо на каждое измерение, но операционка будет делать это сама, если в структуре поставить сюда единичку. Хреначить будет на максимальной частоте, то есть как только преобразование завершено, сразу по новой. Если ставить сюда 0, надо запускать по внешнему событию с помощью следующего поля. Если не сделать ни то, ни другое, чуда не произойдет.

`EXTEN` позволяет выполнять преобразования по внешнему сигналу и выбирает условие триггера (нарастающий фронт, падающий фронт или оба).

`EXTSEL` указывает источник внешнего сигнала. Из вариантов - канал таймера, триггер таймера, и внешняя нога. Работа по таймеру требует, как это не удивительно, полноценного [старта таймера](GPT_setup.md). При этом для триггерного события необходимо это событие бросать. Для этого в конфигурации таймера надо задать в регистре `CONTROL_REGISTER2` в поле `MMS` или `MMS2` что-нибудь, что будет создавать событие `TRGO` или `TRGO2` (их может не быть у таймера в принципе). Самое простое - выбрать режим `Update` (смотри последний пример в текущей инструкции). Для `TRGO` выбор по какому фронту сработает преобразование не актуален, на один триггер одно измерение. Остальные варианты возможно будут описаны позже.

`SMPR1` и `SMPR2`:

Здесь в двух регистрах указывается длительность сэмплирования для каждого канала. В первом регистре настраиваются каналы с 10 по 18, в втором - с 0 по 9. Настройка каждого канала идентична и состоит из трех бит, с помощью которых выбирается количество тактов (от 3-х до 480-и) небходимых на преобразование. Чем больше дать времени, тем более точный будет результат. Номинально на каждый канал даётся 3 такта.

Задать значение с помощью стандартных определений можно двумя способами: использовать дефайны для каждого бита `ADC_SMPR1_SMP10_1 | ADC_SMPR1_SMP10_2` или задать значение для всего поля используя `ADC_SMPR1_SMP_AN10(ADC_SAMPLE_144)`. Оба этих варианта определяют длительность измерения на 10 канале АЦП в 144 такта, установив значение 6 (0b110) в поле `SMP10`. 

`htr` и `ltr`:

В эти регистры указывают верхний и нижний пределы для сторожевой системы. Если напряжение на ноге выйдет за эти пределы драйвер АЦП бросит прерывание с флагом `ADC_ERR_WATCHDOG` и уйдет в `idle` режим. В помощь заполнения есть дефайны `ADC_HTR(n)` и `ADC_LTR(n)`, где `n` - желаемой число. Если написать число больше чем можно, запишутся все единицы. При этом бит в регистре всегда 12, но надо помнить, что разрешение может быть не 12 бит и сюда надо ставить соответствующие диапазоны. Если сторожевая система АЦП не включена, эти поля ничего не делают.

`sqr1`, `sqr2` и `sqr3`:

В `sqr1` есть поле `L` в котором задается длина последовательности (количество каналов), но можно ничего не писать, так как `ChibiOS` сделает это сама взяв значение из `num_channels`. Остальные поля одинаковые и описывают все 16 элементов последовательности, начиная с конца. Заполнять надо ровно столько, какую длину указали (больше можно, но будет сбивать с толку). То есть если длина 3, то надо определить первый, второй и третий элементы последовательности. Каждый элемент это 5 бит, определяющие канал, который надо прочитать. В помощь есть дефайны аналогичные `ADC_SQR3_SQ1_N(n)`, где 3 это номер регистра, 1 - номер элемента, `n` - канал, например `ADC_CHANNEL_IN0`.

## Как же этим пользоваться?

API `ChibiOS` предлагает к использованию следующий набор функций:

```c
void adcStart(ADCDriver *adcp, const ADCConfig *config);
void adcStop(ADCDriver *adcp);
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth);
void adcStartConversionI(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth);
void adcStopConversion(ADCDriver *adcp);
void adcStopConversionI(ADCDriver *adcp);
msg_t adcConvert(ADCDriver *adcp,
                const ADCConversionGroup *grpp,
                adcsample_t *samples,
                size_t depth);
void adcAcquireBus(ADCDriver *adcp);
void adcReleaseBus(ADCDriver *adcp);
bool adcIsBufferComplete(ADCDriver *adcp);
void adcSTM32EnableTSVREFE(void);
void adcSTM32DisableTSVREFE(void);
void adcSTM32EnableVBATE(void);
void adcSTM32DisableVBATE(void);
```

Функция `adcStart()` и `adcStop()` ведут себя как и для любого аналогичного драйвера, есдинственное, что для старта функция конфигурации драйвера фактически не испоьзуется, хотя передать что-нибудь надо.

`adcStartConversion()` запускает преобразование в асинхронном режиме. Аргументами принимает указатель на запущенный драйвер, указатель на структур конфигурации каналов (это которая страшная), указатель на буфер, куда класть значения и значение глубины буфера. По сути дела буфер из себя представляет из себя матрицу `MxN`, где `M` это количество каналов, а `N` - количество измерений, или же глубина. Вот только описана эта матрица одномерным массивом с длиной `M * N`. Если выбран непрерывный (`circular`) режим работы, настроена функция прерывания по окончанию преобразования и глубина буфера беольше единицы, то указанная функция дернется дважды - в середине преобразования (по глубине) и в конце. В связи с этим **настоятельно рекоммендуется** глубину делать чётной. У самой `ChibiOS` проблем возникнуть не должно, но вот себе жизнь импортить можно из-за половинок разного размера.

`adcStartConversionI()` делает все то же самое, что и `adcStartConversion()` но из прерываний.

`adcStopConversion()` останавливает преобразование, принимает только указатель на запущенный драйвер. `adcStopConversionI()` - то же самое, но из прерываний.

Если в `halconf.h` включен `ADC_USE_WAIT`, можно воспользоваться функцией `adcConvert()`. Она работает так же как и `adcStartConversion()`, но ждет окончания преобразования. То есть на следующей строчке в буффере точно лежат измеренные значения. Так же функция возвращает статус драйвера по результату работы функции. Тип значения `msg_t`. Возможные значения: `MSG_OK`, `MSG_RESET`, `MSG_TIMEOUT`. На всякий случай еще раз, блокирующей функцией за редким исключением не стоит пользоваться при непрерывном режиме работы, сама она никогда не закончит работу.

Если в `halconf.h` включен `ADC_USE_MUTUAL_EXCLUSION`, появится доступ к функциям `adcAcquireBus()` и `adcReleaseBus()`. Нужны, чтобы нельзя было одновременно воспользоваться одним драйвером из разных потоков.

Перед началом работы с драйвером вызываем `adcAcquireBus()`, а после окончания работы отпускаем его с помощью `adcReleaseBus()`. Если при обращению к драйверу он окажется занят, поток встанет в очередь и будет ждать. Аргументом функций является указатель на драйвер.

Функция `adcIsBufferComplete()` имеет вполне говорящее имя и возвращает флаг, закончено ли преобразование. Принимает указатель на работающий драйвер.

`adcSTM32EnableTSVREFE()` и `adcSTM32EnableVBATE()` разрешают измерения датчика температуры и опорного напряжения для него и напряжения на входе для батарейки соответственно. `adcSTM32EnableVBATE()` и `adcSTM32DisableVBATE()` в свою очередь их запрещают.

## Разные примеры

Все программы написаны под NUCLEO-F767ZI.

Самый простой пример, нам нужно по запросу узнать напряжение на ноге.

```c 
#include "ch.h"
#include "hal.h"
#include <chprintf.h>

// Включаем UART через USB, чтобы выводить значения в терминал эклипса
static const SerialConfig sd_st_cfg = {
    .speed = 115200,
    .cr1 = 0, .cr2 = 0, .cr3 = 0
};

static SerialDriver         *debug_serial = &SD3;
static BaseSequentialStream *debug_stream = NULL;

void debug_stream_init( void )
{
    sdStart( debug_serial, &sd_st_cfg );
    palSetPadMode( GPIOD, 8, PAL_MODE_ALTERNATE(7) );
    palSetPadMode( GPIOD, 9, PAL_MODE_ALTERNATE(7) );

    debug_stream = (BaseSequentialStream *)debug_serial;
}

void dbgprintf( const char* format, ... )
{
    if ( !debug_stream )
        return;

    va_list ap;
    va_start(ap, format);
    chvprintf(debug_stream, format, ap);
    va_end(ap);
}

ADCConversionGroup adcconf1 = {
    // Непрерывный режим не нужен
    .circular = FALSE,
    // Канал всего один
    .num_channels = 1,
    // Callback функции не нужны
    .end_cb = NULL,
    .error_cb = NULL,
    // Здесь можно поменять разрешение (номинально 12 бит) и включить watchdog (сейчас выключен)
    .cr1 = 0,
    // Пусть Chibi сама разбирается, как запускать преобразование
    .cr2 = ADC_CR2_SWSTART,
    // Выбираем для третьего канала АЦП самый быстрый режим работы, 3 такта на одно преобразование
    .smpr1 = 0,
    .smpr2 = ADC_SMPR2_SMP_AN3(ADC_SAMPLE_3),
    // Watchdog выключен, значит и пределы никого не интересуют
    .htr = 0,
    .ltr = 0,
    // Так как канал только один, значит указываем только в первом элементе последовательности желаемый канал
    .sqr1 = 0,
    .sqr2 = 0,
    .sqr3 = ADC_SQR3_SQ1_N(ADC_CHANNEL_IN3)

};

// Выделяем буфер под преобразование
static adcsample_t buf[1] = {0};

int main(void) {

    halInit();
    chSysInit();
    debug_stream_init();
    // Устанавливаем ногу в режим на вход и запускаем АЦП модуль
    palSetLineMode(PAL_LINE(GPIOA, 3), PAL_MODE_INPUT_ANALOG);
    adcStart(&ADCD1, NULL);

    while (true) {
        // Просим сделать одно преобразование в синхронном режиме и выплевываем его в терминал
        adcConvert(&ADCD1, &adcconf1, buf, 1);
        dbgprintf("%d\n\r", buf[0]);
        chThdSleepMilliseconds(1000);

    }
}
```

Теперь посмотрим как работает `Watchdog` и добавим не единичную глубину буфера.

```c 
#include "ch.h"
#include "hal.h"

// Зададим функцию прерывания по окончанию преобразования
void endcbfun(ADCDriver* adcp)
{
    (void)adcp;
    // Просто моргаем лампочкой
    palToggleLine(LINE_LED2);
}

// И определим функцию если произойдет ошибка
void errcbfun(ADCDriver* adcp, adcerror_t err)
{
    (void)adcp;
    // Если ошибку бросит watchdog, будем мигать другой лампочкой
    if(err == ADC_ERR_WATCHDOG)
        palToggleLine(LINE_LED1);
}

ADCConversionGroup adcconf1 = {
    // Без непрерывного режима
    .circular = FALSE,
    // Все еще 1 канал
    .num_channels = 1,
    // Укажим определенные ранее функции
    .end_cb = endcbfun,
    .error_cb = errcbfun,
    // Включим watchdog, разрешим ему поднимать флаг прерывания, скажем ему смотреть на каждый канал по отдельности и укажем третий канал
    .cr1 = ADC_CR1_AWDEN | ADC_CR1_AWDIE | ADC_CR1_AWDSGL | ADC_CR1_AWDCH_0 | ADC_CR1_AWDCH_1,
    // Оставим запуск преобразования на ChibiOS
    .cr2 = ADC_CR2_SWSTART,
    // Поставим самое долгое время преобразования, 480 тактов (потому что можем)
    .smpr1 = 0,
    .smpr2 = ADC_SMPR2_SMP_AN3(ADC_SAMPLE_480),
    // Зададим пределы для сторожевой системы. Сверху предела нет, снизу примерно четверть от максимального напряжения
    .htr = 0xFFF,
    .ltr = 1000,
    // Укажем третий канал
    .sqr1 = 0,
    .sqr2 = 0,
    .sqr3 = ADC_SQR3_SQ1_N(ADC_CHANNEL_IN3)

};

// Определим буфер для результата преобразования
static adcsample_t buf[4] = {0, 0, 0, 0};

int main(void) {
    halInit();
    chSysInit();
    // Переведем ногу в режим на выход и включим АЦП
    palSetLineMode(PAL_LINE(GPIOA, 3), PAL_MODE_INPUT_ANALOG);
    adcStart(&ADCD1, NULL);
    while (true) {
        // Раз в секунду делаем преобразование. Если напряжение выше нижнего порога, то моргает вторая лампочка (LINE_LED2, то есть все ок), если ниже, то моргает первая лампочка (LINE_LED1, то есть все не ок). Причем первое преобразование в любом случае выполнится и первый элемент обновится, но тут случится прерывание, преобразование остановится и оставшиеся элементы буфера не изменятся. С другой стороны, если решили считать это за ошибку, использовать данные скорее всего и так не имеет смысла.
        adcConvert(&ADCD1, &adcconf1, buf, 4);
        chThdSleepMilliseconds(1000);
    }
}

```

Попробуем запустить АЦП в асинхронном режиме и добавим несколько каналов. Такой режим позволяет один раз запустить чтение сигнала на ноге и в любой момент иметь возможность быстро получить актуальное значение
```c 
#include "ch.h"
#include "hal.h"

// Зададим функцию прерывания по окончанию преобразования
void endcbfun(ADCDriver* adcp)
{
    (void)adcp;
    // Просто моргаем лампочкой. В этот раз лампочка будет мигать так часто, что глазом мигания видно не будет, просто будет гореть
    palToggleLine(LINE_LED2);
}

// В этот раз посмотрим другу ошибку. В DMAFAILURE попадает в том числе некорректный запуск преобразования
void errcbfun(ADCDriver* adcp, adcerror_t err)
{
    (void)adcp;
    if(err == ADC_ERR_DMAFAILURE)
        palToggleLine(LINE_LED1);
}

ADCConversionGroup adcconf1 = {
    // Включаем непрерывный режим
    .circular = TRUE,
    // Укажем три канала
    .num_channels = 3,
    // Все те же callback функции
    .end_cb = endcbfun,
    .error_cb = errcbfun,
    // Watchdog работает, но смотрит все каналы сразу
    .cr1 = ADC_CR1_AWDEN | ADC_CR1_AWDIE,
    // За пуск преобразования отвечает все еще ChibiOS
    .cr2 = ADC_CR2_SWSTART,
    // Укажем каждому каналу свое время преобразования, не, нуачо
    .smpr1 = ADC_SMPR1_SMP_AN10(ADC_SAMPLE_144) | ADC_SMPR1_SMP_AN13(ADC_SAMPLE_15),
    .smpr2 = ADC_SMPR2_SMP_AN3(ADC_SAMPLE_480),
    // Пределы для сторожевой собаки
    .htr = 0xFFF,
    .ltr = 100,
    // Укажем каналы для первых трех элементов
    .sqr1 = 0,
    .sqr2 = 0,
    .sqr3 = ADC_SQR3_SQ1_N(ADC_CHANNEL_IN3) | ADC_SQR3_SQ2_N(ADC_CHANNEL_IN10) | ADC_SQR3_SQ3_N(ADC_CHANNEL_IN13)

};

// Зададим буфер. Обратите внимание, в предыдщем примере он был на три элемента из-за глубины, в этот раз из-за количества каналов
static adcsample_t buf[3] = {0};

int main(void) {

    halInit();
    chSysInit();
    // Переведем ноги в режим на вход
    palSetLineMode(PAL_LINE(GPIOA, 3), PAL_MODE_INPUT_ANALOG);
    palSetLineMode(PAL_LINE(GPIOC, 0), PAL_MODE_INPUT_ANALOG);
    palSetLineMode(PAL_LINE(GPIOC, 3), PAL_MODE_INPUT_ANALOG);
    // Запустим модуль АЦП
    adcStart(&ADCD1, NULL);
	// Начнем преобразование
    adcStartConversion(&ADCD1, &adcconf1, buf, 1);
    // А затем все сломаем к чертям. Здесь стоит обратить внимание, что передача остановится в любом случае и мы можем об этом даже не узнать, поэтому используем прерывание по ошибке
    adcStartConversion(&ADCD1, &adcconf1, buf, 1);
    // Так как на предыдущей строке передача остановилась, можем сразу запускать заново
    adcStartConversion(&ADCD1, &adcconf1, buf, 1);
    while (true) {
	    // Раз в секунду будем забирать данные из буфера. Если в процессе работы напряжение на любом канале упадет ниже 100 (настройки watchdog), АЦП остановится, данные в буфере перестанут обновляться, а мы об этом даже не узнаем (а вот если бы обработали ошибку в прерывании...)
        uint16_t ch1 = buf[0];
        uint16_t ch2 = buf[1];
        uint16_t ch3 = buf[2];
        chThdSleepMilliseconds(1000);

    }
}
```

Ну и напоследок рассмотрим вариант работы по таймеру
```c 
#include "ch.h"
#include "hal.h"

// Определим количество каналов
#define NUM_OF_CHANNELS 3
// И глубину измерений
#define ADC_DEPTH 1502


void tim1cb(GPTDriver* gptp)
{
    (void)gptp;
    palToggleLine(PAL_LINE(GPIOB, 8));
}

// Настроим таймер (не забыв его включить в halconf.h и mcu.h)
static const GPTConfig tim1_conf = {
    // Зададим частоту
    .frequency = 27000000,
    // Прерывание не обязательно, но им все еще можно пользоваться
    .callback = tim1cb,
    // Скажем таймеру делать TRGO событие
    .cr2 = TIM_CR2_MMS_1,
    .dier = 0
};

// Настроим прерывание для АЦП
void endcbfun(ADCDriver* adcp)
{
    (void)adcp;
    // Прерывание сработает дважды за одно измерение, делать что-нибудь будем только по окончанию буфера
    if(adcIsBufferComplete(&ADCD1))
        palToggleLine(PAL_LINE(GPIOB, 9));
    // Здесь есть нюанс связанный с работой кэша. DMA может класть это в память, отведенную под кэш, в этом случае данные могут переписываться. 
    // В этом примере этот вопрос опускается, имейте в виду потенциальное существование проблемы
}

ADCConversionGroup adcconf1 = {
    // Непрерывный режим работы
    .circular = TRUE,
    // Количество каналов через дефайн, чтобы не менять во всех местах при необходимости
    .num_channels = NUM_OF_CHANNELS,
    // Укажем функцию прерывания
    .end_cb = endcbfun,
    // Ошибку игнорируем, хотя возможно и не стоит
    .error_cb = NULL,
    // Без сторожевого пса
    .cr1 = 0,
    // Запуск преобразованию по TRGO первого таймера, так как именно его мы включили
    .cr2 = ADC_CR2_EXTEN_RISING | ADC_CR2_EXTSEL_SRC(0b1001),
    // Самое быстрое сэмплирование для всех каналов
    .smpr1 = ADC_SMPR1_SMP_AN10(ADC_SAMPLE_3) | ADC_SMPR1_SMP_AN13(ADC_SAMPLE_3),
    .smpr2 = ADC_SMPR2_SMP_AN3(ADC_SAMPLE_3),
    // Без системы watchdog эти два поля неактуальны
    .htr = 0,
    .ltr = 0,
    // Первыми тремя элементами укажем выбранные каналы
    .sqr1 = 0,
    .sqr2 = 0,
    .sqr3 = ADC_SQR3_SQ1_N(ADC_CHANNEL_IN3) | ADC_SQR3_SQ2_N(ADC_CHANNEL_IN10) | ADC_SQR3_SQ3_N(ADC_CHANNEL_IN13)

};

// Определим буфер. Несмотря на то, что данные по сути дела являются матрицей, массив всё еще одномерный, с размером равным глубине преобразования умноженному на количество каналов
static adcsample_t buf[NUM_OF_CHANNELS * ADC_DEPTH] = {0};

// Буферы для разделения на каналы
uint16_t bufA[ADC_DEPTH] = {0};
uint16_t bufB[ADC_DEPTH] = {0};
uint16_t bufC[ADC_DEPTH] = {0};

int main(void) {

    halInit();
    chSysInit();
    // Запустим модуль таймера
    gptStart(&GPTD1, &tim1_conf);
    // И АПЦ
    adcStart(&ADCD1, NULL);
    // Поставим ноги на вход
    palSetLineMode(PAL_LINE(GPIOA, 3), PAL_MODE_INPUT_ANALOG);
    palSetLineMode(PAL_LINE(GPIOC, 0), PAL_MODE_INPUT_ANALOG);
    palSetLineMode(PAL_LINE(GPIOC, 3), PAL_MODE_INPUT_ANALOG);
    // Эти нужны были для отладки, в работе АЦП не участвуют
    palSetLineMode(PAL_LINE(GPIOB, 8), PAL_MODE_OUTPUT_PUSHPULL);
    palSetLineMode(PAL_LINE(GPIOB, 9), PAL_MODE_OUTPUT_PUSHPULL);
    // Запустим преобразование
    adcStartConversion(&ADCD1, &adcconf1, buf, ADC_DEPTH);
    // Стартанем таймер с частотой 27кГц. 27МГц частота тактирования и 1000 тактов до совпадения. К слову, если преобразование займёт больше времени, чем период таймера, ошибки никакой не случится (в смысле программной, так-то это не нормальное поведение). Судя по экспериментам преобразование начнётся мгновенно после окончания предыдущего, так что про синхронизацию можно будет забыть. Имейте это в виду.
    gptStartContinuous(&GPTD1, 1000);

    while (true) {
        // Так делать не стоит, так как потеряете данные полученные во время паузы. Это просто демонстрация как расположены данные в буфере
        uint16_t i;
        for(i = 0; i < ADC_DEPTH; i++) {
            bufA[i] = buf[i * 3];
            bufB[i] = buf[i * 3 + 1];
            bufC[i] = buf[i * 3 + 2];
        }
        chThdSleepMilliseconds(1000);
    }
}
```
