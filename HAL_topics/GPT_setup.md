# Заводим таймер на STM-ке

Все таймеры важны, все таймеры нужны.

Сначала, нужно определиться какой таймер свободен. У `STM32` таймеры бывают `Advanced-control`, `General purpose` и `Basic`. Вообще они достаточно сильно отличаются, но сами отличия проявляются в работе других модулей (например `PWM`). В данном случае мы будем их все воспринимать как `General Purpose Timer (GPT)`.

Если открыть файл `mcuconf.h`, можно увидеть список таймеров в виде дефайнов `STM32_GPT_USE_TIMx`, где `x` - номер таймера. На `STM32F767ZI` их 17, но если выбрать, например, 16, получим ошибку

```bash
TIM16 not present in the selected device
```

Удивишись, идём читать [даташит](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=39) (**разумеется на свой контроллер!**). Видим, что на самом деле таймеров 14, причём они могут быть разной разрядности и с разной максимальной частотой. На что это влияет, разберём дальше.

Каждый таймер может работать только на одну задачу, то есть если мы хотим первый таймер использовать как `GPT` и повесить на него `PWM`, получим ошибку вроде такой:

```bash
PWMD1 requires TIM1 but the timer is already used
```

Кроме того, один таймер всегда используется под саму операционную систему. Какой именно можно узнать в `mcuconf.h` в поле `STM32_ST_USE_TIMER`. Скорее всего используется второй, так как он 32-битный. Если хочется повесить систему на 16-битный таймер, в файле `chconf.h` надо определить `CH_CFG_ST_RESOLUTION` как 16, но зачем?

## Первый шаг - Познакомим STM-ку с таймером

Чтобы всё выше описанное имело хоть какое-то значение, надо включить модуль с помощью `HAL_USE_GPT` в `halconf.h` и включить выбранный таймер с помощью `STM32_GPT_USE_TIMx` в `mcuconf.h`. Если не понятно о чём речь, смотрим [сюда](Basics.md).

## Второй шаг - Настройка конфигурации таймера 

Как и с любым модулем, для его запуска нужно выполнить инструкцию: 
```c
gptStart(gptDriver* gptp, GPTConfig *config)
```

Первый аргумент это указатель на объект драйвера. Имя объекта - `GPTDx`, где `x` - выбранный таймер. А второй аргумент это структура конфигурации.

Выглядит структура следующим образом:

```cpp
typedef struct {
  gptfreq_t                 frequency;
  gptcallback_t             callback;
  uint32_t                  cr2;
  uint32_t                  dier;
} GPTConfig;
```

Поле `frequency` - частота тиков в герцах. Вкупе со значением периода (`Interval`) определит время до переполнения таймера-счётчика, то есть, собственно, время работы таймера. 
    
Чем больше задается частота, тем выше разрешение таймера, но здесь стоит вспомнить про разрядность таймера, в 16-битном, максимальное значение периода $2^{16}$, а в 32-битном - $2^{32}$, соответственно.  

Писать можно любое целое число, которое можно получить с помощью 16-битного предделителя исходя из частоты шины. Если, вдруг, предыдущее предложение было предельно ясно, следующий фрагмент можно пропустить.

Частота ограничена сверху частотой шины, а снизу глубиной предделителя. 

Причем так как предделитель может принимать только **целые значения**, частота тактирования шины должна делиться на желаемую частотау таймера **нацело**.

Таймеры могут висеть на шинах `APB1` или `APB2`. На какой именно шине висит каждый таймер можно посмотреть [тут](https://www.st.com/content/ccc/resource/technical/document/datasheet/group3/c5/37/9c/1d/a6/09/4e/1a/DM00273119/files/DM00273119.pdf/jcr:content/translations/en.DM00273119.pdf#page=20).

На картинке видно, что таймеры 2, 3, 4, 5, 6, 7, 12, 13, 14 относятся к `APB1`. А таймеры 1, 8, 9, 10, 11 `APB2`.

<p align="center">
<img src="gpt_pics/fig1.PNG" width=700/>
</p>

Частота шины вычисляется, как: 

$$\text{Частота шины} = \frac{\text{частота процессора}}{\text{предделитель}}$$

Значение предделителя можно подглядеть в `mcuconf.h`. 

`STM32_PPRE1` является предделителем для `APB1`, а `STM32_PPRE2` для `APB2`. Однако, экспериментально определено, что на самом деле частота таймера может превышать частоту ШИМ в два раза (вероятнее всего, триггером для таймера являются и нарастающий и падающий фронты). 

То есть для первого таймера STM32F767ZI получается, что частота процессора 216МГц, предделитель `APB2`номинально установлен в двойку, а значит максимальная частота 216МГц ($216 / 2 * 2$), а минимальная - 3295,898Гц ($216000000 / 2^{16}$). Но, так как поле в структуре также должно быть целым, выходит,
что минимальное допустимое значение - 3375 ($216000000 / 64000$).

Если ввести неверное значение, то в дело вступит магия целочисленной математики. Например, если частота шины 216МГц, а в поле `frequency` установить число 210_000_000, так как необходимое значение предделителя состовляет ~1.03, то на самом деле предделитель будет единица и частота таймера будет 216МГц.

Поле `callback` - указатель на функцию прерывания, которая сработает при окончании работы таймера. Варианты работы таймеры рассмотрим чуть ниже. В поле можно указать имя функции, которая принимает только указатель на драйвер `GPT` и ничего не возвращает. То есть выглядеть она может только так:

```c
void cbgpt(GPTDriver *gptp)
{
    (void)gptp;    \\ Это не обязательно, просто чтобы не было предупреждений о неиспользуемой переменной

    ...
    do something
    ...
}
```

Если прерывание не нужно, вместо функции пишем `NULL`.

Оставшиеся два поля - регистры `TIMx CONTROL REGISTER2` и `TIMx DMA/INTERRUPT ENABLE REGISTER`. Теоретически, можно попробовать настроить Direct Memory Access запросы, но скорее всего не понадобится, так что смело оставляем нулями.

## Третий шаг - Непосредственно использование таймера

API `ChibiOS` предлагает следующий набор функций для работы с модулем:

  - `void gptStart(GPTDriver *gptp, const GPTConfig *config);`
  - `void gptStop(GPTDriver *gptp);`
  - `void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval);`
  - `void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval);`
  - `void gptChangeInterval(GPTDriver *gptp, gptcnt_t interval);`
  - `void gptStartOneShot(GPTDriver *gptp, gptcnt_t interval);`
  - `void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval);`
  - `void gptStopTimer(GPTDriver *gptp);`
  - `void gptStopTimerI(GPTDriver *gptp);`
  - `void gptPolledDelay(GPTDriver *gptp, gptcnt_t interval);`
  - `gptcnt_t gptGetIntervalX(GPTDriver *gptp);`
  - `gptGetCounterX(GPTDriver *gptp);`
  
С функциями `gptStart()` и `gptStop()` наверняка и так всё понятно. Запустили, сделали что-нибудь и остановили.

`gptStartContinuous()` запускает таймер в непрерывную работу. Аргументами являются указатель на драйвер включенного таймера и желаемый период в тиках таймера. Так как частота таймера настраивается, желаемый период в секундах придётся рассчитывать самостоятельно. Сделать это можно по формуле $n = T / f$, где $n$ - необходимое количество тактов, $T$ - желаемый период в секундах, $f$ - заданная частота в герцах. Напомню, что для 16-битного таймера максимальное количество тактов это 65535 ($2^{16} - 1$), а для 32-битного - 4_294_967_295 ($2^{32} - 1$). Если превысить это значение, использованы будут только 2 или 4 младших байтов в зависимости от разрядности. 

`gptStartContinuousI()` - делает всё то же самое, но работает из прерываний.

`gptChangeInterval()` позволяет изменить период работающего таймера без его остановки, принимает указатель на драйвер и период в тактах.

`gptStartOneShot()` запускает таймер на один период. Принимает указатель на драйвер и время в тактах. Если не указан обработчик прерывания, то эта функция не доступна.

`gptStartOneShotI()` делает то же самое, что и `gptStartOneShot()`, но работает из прерываний.

`gptStopTimer()` останавливает запущенный в непрерывную работу таймер. Принимает указатель на драйвер таймера.

`gptStopTimerI()` то же самое, что и `gptStopTimer()`, но из прерывания.

`gptPolledDelay()` - задержка, которая вешает систему (**прям намертво**) на заданное время. Этим стоит пользоваться для коротких пауз, когда нужна большая точность, но точно **не злоупотреблять**. Принимает указатель на драйвер и время в тактах.

`gptGetIntervalX()` возвращает текущее значение периода таймера, работающего в неприрывном режиме. Тип возвращаемого значения `gptcnt_t` (на самом деле это `uint32_t`), принимает указатель на драйвер таймера. Можно вызывать откуда угодно.

`gptGetCounterX()` возвращает текущее значение счётчика таймера, работающего в непрерывном режиме. Тип возвращаемого значения `gptcnt_t` (на самом деле это `uint32_t`), принимает указатель на драйвер таймера. Можно вызывать откуда угодно. *В комментарии к функции сказано, что тип работы счётчика не определён. То есть значение может нарастать или убывать. На STM32F767ZI счётчик нарастающий, но на всякий случай имейте в виду.*

## Ну, и пример

Код для платы NUCLEO-F767ZI
```c
#include "ch.h"
#include "hal.h"

// Будем использовать первый и третий таймеры
GPTDriver *timer1 = &GPTD1;
GPTDriver *timer3 = &GPTD3;

// Определяем две функции обработчика прерываний

// Первая функция просто моргает лампочкой
void cbgptfun1(GPTDriver *gptp)
{
    (void)gptp;
    palToggleLine(LINE_LED1);
}

// Вторая моргает другой лампочкой и каждый раз перезапускает таймер
void cbgptfun2(GPTDriver *gptp)
{
    (void)gptp;
    // Узнаем период первого таймера
    uint16_t T = gptGetIntervalX(timer1);
    gptStartOneShotI(timer3, T);
    palToggleLine(LINE_LED2);
}

// Настраиваем частоту первого таймера 50_000Гц (предделитель 4320, целое число, меньше чем 2^16) и указывает первую функцию как обработчик прерываний
GPTConfig gpt1_conf = {
    .frequency = 50000,
    .callback = cbgptfun1,
    .cr2 = 0,
    .dier = 0
};

// Для третьего таймера настройка такая же (для той же частоты нужен другой предделитель, так как другая шина, но сквозь API этого не видно), но укажем вторую функцию 
GPTConfig gpt3_conf = {
    .frequency = 50000,
    .callback = cbgptfun2,
    .cr2 = 0,
    .dier = 0
};

int main(void) {

    halInit();
    chSysInit();
    // Включим оба таймера
    gptStart(timer1, &gpt1_conf);
    gptStart(timer3, &gpt3_conf);
    // Первый запустим в непрерывном режиме с частотой 2Гц
    gptStartContinuous(timer1, 25000);
    // Определим период первого таймера (потому что можем)
    uint16_t T = gptGetIntervalX(timer1);
    // Стартуем третий таймер с той же частотой
    gptStartOneShot(timer3, T);
    while (true) {
        // Наблюдаем, как две лампочки синхронно моргают
        chThdSleepMilliseconds(1000);
    }
}
```

Вот и всё! Готово! 

<center><img src="https://content.onliner.by/news/default/1cfdc59c39d059d80ae7909945ef75da.jpeg" width=500/></center>