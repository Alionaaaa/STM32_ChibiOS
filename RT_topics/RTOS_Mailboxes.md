# Почтовые ящики

## Описание

Вот и подъехал еще один инструмент управления в ChibiOS. Почтовый ящик (далее - ящик) по системе является FIFO структурой.

Представьте ящик, в который письма положить внутрь можно только сверху, а забрать только снизу. При этом забирать вы будете самое старое письмо из ящика. То есть, первое положенное письмо будет первым при вытаскивании.

Но и тут не все гладко. Функционал в ChibiOS позволяет класть, так сказать, *важные письма*. Под этим понимается важность скорой обработки. Короче, кладутся такие важные письма первее всех - "в голову". То есть, положили такое важное письмо - при следующем заборе (то есть, когда забираем, а не ограждение для огорода :door:) оно будет уже у вас.

Подводя итог, структура иммитирует очередь с некоторыми вкраплениями важности. Кто-то (например поток) кладет инфу в ящик, другой кто-то забирает.

## Программное использование

Интереснее дела обстоят с использованием API данного инструмента.

Тип и инициализация.

```
mailbox_t adc_mb;
```

Вот так выглядит тип объекта (структуры) ящика.

Работает ящик только с данными типа `msg_t`, поэтому для инициализации буффера, на котором будет основываться ящик, неоходимо указать тип `msg_t`. 

Размер ящика определяется размером буффера, который подключается к ящику.

```
msg_t adc_mb_buffer[20];
```

А теперь, два варианта инициализации:

```
MAILBOX_DECL(name, buffer, size)
```

вот так (пример)

```
msg_t adc_mb_buffer[20];
MAILBOX_DECL(adc_mb, adc_mb_buffer, 20);
```

или

```
void chMBObjectInit (mailbox_t *mbp, msg_t *buf, size_t n)
```

вот так (пример)

```
mailbox_t adc_mb;
msg_t adc_mb_buffer[20];
chMBObjectInit(&adc_mb, adc_mb_buffer, 20);
```

В первом случае - инициализация статическая (можно делать вне функции), во втором - инициализация функцией, что вынуждает делать это только внутри другой функции.

Ладно, с инициализацией запары нет, теперь поработаем с самим ящиком.

```
void chMBReset (mailbox_t *mbp)
void chMBResetI (mailbox_t *mbp)
void chMBResumeX (mailbox_t *mbp)
```

Научимся рвать и метать, первые две функции - ввод ящик в состояние `Reset` - сбрасывает все сообщения, вытряхиваем ящик и все выбрасываем. В таком состоянии любая функция (типа `Post` или `Fetch`) возвращает `MSG_RESET`. Третья функция возвращает в нормальное состояние. Принимают указатель на объект.

```
msg_t chMBPostTimeout (mailbox_t *mbp, msg_t msg, sysinterval_t timeout)
msg_t chMBPostTimeoutS (mailbox_t *mbp, msg_t msg, sysinterval_t timeout)
msg_t chMBPostI (mailbox_t *mbp, msg_t msg)
```

Публикуем. Как видно, функции типа `Post` принимают первый аргументом указатель на объект, вторым - сообщение, размещаемое в ящике. В случае с функционалом `Timeout` еще и присутствует поле задания времени. Для них не забываем пользовать константами `TIME_IMMEDIATE` (мгновенно) и `TIME_INFINITE` (бесконечно). Таймаут определяет время ожидания освобождения места в ящике.

**Return:**
+ `MSG_OK` - сообщение в ящике, все ок
+ `MSG_TIMEOUT` - для функций с таймаутом, соответственно сигналит о таймауте; для функции I-class сообщает о полном ящике (невозможно сунуть еще сообщение)
+ `MSG_RESET` - кто-то сделал `Reset` на ящик

```
msg_t chMBPostAheadTimeout (mailbox_t *mbp, msg_t msg, sysinterval_t timeout)
msg_t chMBPostAheadTimeoutS (mailbox_t *mbp, msg_t msg, sysinterval_t timeout)
msg_t chMBPostAheadI (mailbox_t *mbp, msg_t msg)
```

Ох, эти *важные* :crown: сообщения. Если обычные `Post` публикуют в *"хвост"*, то эти публикуют в *"голову"*. Все прототипы по аналогии с предыдущим блоком.

```
msg_t chMBFetchTimeout (mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout)
msg_t chMBFetchTimeoutS (mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout)
msg_t chMBFetchI (mailbox_t *mbp, msg_t *msgp)
```

Научились публиковать, значит надо научиться и забирать сообщения. Когда сообщение забираем (этими функциями) - оно пропадает из ящика.
Первым аргументом также передаем указатель на объект ящика, второй аргумент - указатель на переменную типа `msg_t` для заполнения сообщения.
Такого рода механизм позволяет заполнить возвращаемое значение через аргумент, а через возвращаемое значение показать, насколько удачно все прошло - очень удобно! В общем, создаем переменную, передаем указатель и, если возврат Ок, то значение в переменной заполнилось. С таймаутом все также просто, говорим сколько ждать появления сообщения в ящике.

**Return:**
+ `MSG_OK` - сообщение записано по указателю, из ящика удалено, все ок
+ `MSG_TIMEOUT` - для функций с таймаутом, соответственно сигналит о таймауте; для функции I-class сообщает о пустом ящике (невозможно забрать сообщение)
+ `MSG_RESET` - кто-то сделал `Reset` на ящик

```
size_t chMBGetSizeI (const mailbox_t *mbp)
```

А теперь отдельные функции. Вот эта принимает указатель на объект ящика и говорит о его размере. Зачем - не знаю, может просто для удобства.

**Return:** Размер ящика

```
size_t chMBGetUsedCountI (const mailbox_t *mbp)
size_t chMBGetFreeCountI (const mailbox_t *mbp)
```

Функции определения количества свободных/занятых слотов сообщений. Принимают также указатели на объект ящика.

**Return:** размер соответственно свободных/заполненных слотов

```
msg_t chMBPeekI (const mailbox_t *mbp)
```

Эта вообще *особенная* :tada: функция. И вот как она работает по сравнению со всеми остальными: она не удаляет сообщение из ящика; возвращает значение не через указатель, а через возврат; если сообщений в ящике нет - возвращает мусор. Короче, пользоваться аккуратнее, рекомендуется перед использованием убедиться, что в ящике что-то есть (`chMBGetUsedCountI()`).

**Return:** сообщение в *"голове"* ящике (не удаляется из головы)

### Пример

```
#define BUFFER_SIZE 100

mailbox_t adc_mb;
msg_t adc_mb_buffer[BUFFER_SIZE];

static THD_FUNCTION(PostThread, arg) {
	msg_t i = 0;
	/* TIME_IMMEDIATE - to be sure that processing is fast
	  and fetcher is in time of processing */
	msg_t msg = chMBPostTimeout(&adc_mb, i, TIME_IMMEDIATE);
	if (msg == MSG_OK)
		/* Message put */
	else if (msg == MSG_TIMEOUT)
		/* Mailbox is full, too fast posting */
	else
		/* Reset */
}

static THD_FUNCTION(FetchThread, arg) {
	msg_t my_msg;
	/* If empty - wait for 500 ms */
	msg_t msg = chMBFetchTimeout(&adc_mb, &my_msg, MS2ST(500));
	if (msg == MSG_OK)
		/* Got message, now in <my_msg> */
	else if (msg == MSG_TIMEOUT)
		/* Timeout */
	else
		/* Reset */
}

void main(void) {
	...
	chMBObjectInit(&adc_mb, adc_mb_buffer, BUFFER_SIZE);
	...
}
```

## Рекомендации

Инструмент не сказать, что легкий по использованию, тем не менее рекомендуется к использованию, если нужно получить некоторый буффер в передаче данных между потоками (поток/прерывание). Также можно пользовать при необходимости получения последовательности данных без потерь. Переход в состояние 	`Sleep` во время ожидания сообщения в ящике позволяет все также активно взаимодействовать с диспетчером.

### Полезные ссылки
1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_mailboxes)
2. [Доки](http://chibios.sourceforge.net/docs3/rt/group__mailboxes.html)