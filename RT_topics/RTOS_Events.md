# Памятные события (Events)

## Описание
События, не скажу, что механизм распространен на все ОСРВ, тем не менее данный механизм очень мощный и его использование открывает те возможности, которых не добиться другими инструментами в ChibiOS (IMHO).

Если говорить терминами, то с помощью данного механизма открывается взаимодействие по принципу многие-со-многими. Если проще, то с помощью такого механизма потоки могут ожидать наступления сразу нескольких событий, а также, можно сообщать сразу нескольким потокам о наступлении события.

Разбирать рекомендуется по-немножку, для начала введем глобальные понятия:

### Источник события (*source*)
На источник можно подписаться (*register*) и в источник можно разослать инфу о наступлении события (*broadcast*) слушателям.

### Флаги события (*flags*)
Здесь все интереснее, флаги несут конкретную информацию того, что случилось в событии. Например, источник ассоциирован с последовательным портом и сигналит о событиях на шине, флаги уточнят события - данные переданы, данные приняты, ошибка четности, ошибка фрейма и т.д. Пока не вдаемся в подробности, флаги конкретизируют события.

### Слушатель события (*listener*)
На каждый источник может подписаться несколько слушателей. Соответственно, один слушатель - один поток.

### Маски событий (*mask*)
Маски событий никак не связаны с флагами, это отдельное понятие. **Маска событий** - это битовая маска, каждый бит которой является событием. Таким образом при ожидании конкретного события определить, какое событие случилось можно с помощью битового наложения (операция **И**).

И так, сформируем общую картину данного механизма.

Существуют источники событий, они инициализируются один раз и являются связывающими звеньями между потоками, которые соощают о событиях, и потоками, которые ждут инфы о событии. Для одного источника поток выполняет либо одну роль, либо другую (полагаю ничего не запрещает сразу и подписаться на источник и слать в него инфу, но не вижу в этом смысла).

Таким образом, поток, который ждет события, является слушателем и имеет специальный объект слушателя (структура). Для "публикатора" никакая структура не используется.

Подписываясь на событие, слушатель добавляет к себе в маску событий событие на определенный индекс (по сути на определенный бит). Далее, если публикатор объявил о событии, то у слушателя устанавливается на индексе соответствующего события сигнал о свершении (в маске событий бит в 1 ставится). Таким образом, с помощью маски событий слушатель может узнать о конкретном событии.

Теперь добавим **концепцию флагов**. Флаги лишь уточняют каждое событие, так что слушатель может указать, какое событие он ожидает, когда были установлены флаги. В это время публикатор сообщает о событии и уточняет его флагами. Так, если какой-то флаг, который указал слушатель, сходится с флагом, который уточник публикатор, то слушатель получит событие. Иначе слушатель не будет уведомлен, так как публикатор оповестил о событии с флагами, ни один из которых не интересует слушателя.

*[Также уточнение по механизму, если слушатель подписался с флагами, а публикатор сообщает о событии без флагов - слушатель получит уведомление, только флагов в нем установлено не будет. Выяснил это из кода, хз почему так сделано. :confused:]*

Понимаю, описание достаточно громоздкое, да и понять с первого раза, возможно, не получится. В любом случае, в посте будут представлены общие концепции и конечного понимания после прочтения поста не требуется, так как механизм действительно не просто с точки зрения первого понимания (IMHO).

Теперь про его **асинхронность**, если слушатель зарегистрировался на источник события, то слушателю не обязательно сидеть и ждать события. Так публикатор может сообщить о событии и только после этого слушатель встает в ожидание события. Тем не менее, слушатель сразу получит инфу, так как маски (и флаги при необходимости) всё-таки установлены. Важное условие - **регистрация на источник**.

Это был описан полный механизм действия событий. Также функционал подразумевает укороченный механизм (*прямое сообщение о событии*). В усеченной версии нет источников, слушателей и флагов. Только маска событий, которую поток-публикатор заполняет и оповещает другой поток. В данном варианте нет рассылки (*Broadcast*). Это асинхронный механизм оповещения со структурой один-к-одному. То есть, один поток может оповестить маской событий другой поток по ссылке.

Примерная схема внутренностей представлена на следующем рисунке:

<p align="center">
<img src="http://wiki.chibios.org/dokuwiki/lib/exe/fetch.php?media=chibios:kb:events-001.png">
</p>

На нем видно, что несколько слушателей могут подписаться на один источник, каждый слушатель - отдельный поток, у каждого потока событие стоит на своём месте в маске событий. Единственное, картинка не отображает флагов событий, но с ними, полагаю, все более-менее понятно.

Ух, ну и много всего было написано, теперь перейдем к API в ChibiOS.

### Программное использование

Для упрощения предлагается следующий подход, в разделе "Примеры использования" представлены кусочки кода для улучшения понимания работы с событиями. Примеры полноценного кода представлены в книге.

#### Определение типов:

```
event_source_t  	event_src;
event_listener_t 	event_lnr;
eventmask_t    		event_msk;
eventflags_t   		event_flgs;
```

Типы определяют все составные части событий, источник необходимо определить так, чтобы он был доступен всем потокам (возможно глобально, но есть и другие варианты), слушателя достаточно определить внутри потока, так как несколько потоков не могут быть одним слушателем, маска и флаги точно определяются локально внутри потока.

#### Теперь к функциям инициализации:

```
EVENTSOURCE_DECL(name)
void chEvtObjectInit (event_source_t *esp);
```

Обе функции производят инициализацию источника, в первом случае инициализация макросом. То есть, для инициализации макросом отдельно определять объект (структуру) источника **не надо**.

Во втором случае инициализация функцией и для неё необходимо **явно определить объект источника**.

#### Далее рассмотрим основные функции для использования механизма.

```
void chEvtRegister (event_source_t *esp, event_listener_t *elp, eventid_t event)
void chEvtRegisterMask (event_source_t *esp, event_listener_t *elp, eventmask_t events)
void chEvtRegisterMaskWithFlags (event_source_t *esp, event_listener_t *elp, eventmask_t events, eventflags_t wflags)
```

Ух, три функции с такой большой начинкой по аргументам. Все три функции регистрируют слушателя на источник, но делают это по-разному.

Во всех функциях передаём указатели на источник и слушателя. Остальные аргументы как раз различают функционал.

`chEvtRegister()` - передаем идентификатор `eventid_t`, под которым источник будет записан в слушателя. Максимальный идентификатор определяется количеством бит в размере типа `eventmask_t` минус один. *[В нашем случае - размер `eventmask_t == 32`, соответственно идекс может быть от 0 до 31.]* Каждый слушатель записывает событие под своим идентификатором в маску, так один поток может записать событие на ID 5, а другой на ID 2. Аналогично оба могут записать под одинаковый идентификатор (потоки-слушатели никак не пересекаются).

`chEvtRegisterMask()` - аналогичный функционал с первой функцией, только вместо идентификатора передаем сформированную с помощью макроса `EVENT_MASK(eid)` маску.

`chEvtRegisterMaskWithFlags()` - расширение второй функции флагами. Флаги должны представлять из себя битовые поля (см. примеры).

```
void chEvtUnregister (event_source_t *esp, event_listener_t *elp)
```

Необходимо также уметь отменять регистрацию слушателя на событие. Указатели соответствуют названиям в аргументах.

После настройки (регистрации) можно спокойно приступать к работе с событиями и начнём со слушателя.

```
eventmask_t chEvtWaitOne (eventmask_t events)
eventmask_t chEvtWaitAny (eventmask_t events)
eventmask_t chEvtWaitAll (eventmask_t events)
```

Функции ожидания событий, различаются логикой. Всем передается маска, которая информирует о том, какие события ждать. Ожидать несколько событий (сформировать маску из нескольких) можно с помощью макроса `EVENT_MASK()` и операции OR.

**Return:** маска сработавщих (случившихся) событий.

`chEvtWaitOne()` - ожидает одно едиственное событие. В агрумент можно передать и несколько, но вернет оповещение `(return)` только о случившемся событии с младшим `eid`. Возвращаемая маска всегда заполнена единственным битом.

`chEvtWaitAny()` - ожидает одно из переданных событий. Эта функция больше подходит для ожидания событий по принципу "хотя бы один из". Формируем маску из нескольких масок событий и ждем пока одно из них не случится. Может, конечно, так произойти, что случится сразу несколько из ожидаемых, тогда в возвращаемой маске будут установлены несколько бит.

`chEvtWaitAll()` - Ожидание, пока не произойдут все переданные события. Соответственно, когда такой момент настанет, возвращаемая маска должна быть идентична переданной аргументом.
Также можно добавить, что существует макро-определение с названием `ALL_EVENTS`, которое обозначает все события, на которые подписан слушатель и очень хорошо подходит для функции `chEvtWaitAny()`, если надо подождать хотя бы одно из событий, на которые подписался поток.

```
eventmask_t chEvtWaitOneTimeout (eventmask_t events, systime_t timeout)
eventmask_t chEvtWaitAnyTimeout (eventmask_t events, systime_t timeout)
eventmask_t chEvtWaitAllTimeout (eventmask_t events, systime_t timeout)
```

Функционал идентичен предыдущей группе. Разница в наличии таймаута ожидания. Для работы с ними в конфигурации должен быть установлен параметр `CH_CFG_USE_EVENTS_TIMEOUT`.

#### Теперь перейдем к публикатору, как же все таки ему оповещать о событиях?

```
void chEvtBroadcast (event_source_t *esp)
void chEvtBroadcastI (event_source_t *esp)
void chEvtBroadcastFlags (event_source_t *esp, eventflags_t flags)
void chEvtBroadcastFlagsI (event_source_t *esp, eventflags_t flags)
```

#### Рассылка. 

Как видно, она не привязана к слушателям, для неё важен только источник. Передаем указатель на источник, тем самым оповещая о свершении события.

Тут имеется работа с флагами и, аналогично регистрации на флаги, можно сообщить о событии с определёнными флагами. Сложение флагов также по принципу битового поля (операция OR). Рассылка в источник оповещает всех слушателей, которые зарегистрированы на источник. В случае с флагами (псоледние две). Оповещение дойдёт, если только слушатель интересуется переданными флагами.

*[Если слушатель подписался на флаги, а публикатор рассылает без флагов, слушатель получит уведомление, только при проверке флагов ни один не будет установлен.]*

```
eventflags_t chEvtGetAndClearFlags (event_listener_t *elp)
eventflags_t chEvtGetAndClearFlagsI (event_listener_t *elp)
```

Функция полезна при регистрации с флагами. После того, как было получено уведомление о событии, на которое слушатель подписался с флагами, можно проверить, какие флаги были установлены в событии.

Аргументом передается указатель на объект слушателя.

**Return:** битовое поле флагов, в котором установлены биты, соответствующие случившимся флагам. *[Например, подписаны на событие Serial с флагами `TX_ERROR_FLAG | RX_ERROR_FLAG`, публикатор оповестил Serial event только `TX_ERROR_FLAG`, тогда в возвращаемом поле флагов будет установлен только `TX_ERROR_FLAG`.]*

На этом работа с основным механизмом описана. Теперь немного сервисных функций и укороченный (прямой один-к-одному) механизм.

```
bool chEvtIsListeningI (event_source_t *esp)
```

Проверка, зарегистрировался ли хоть кто-нибудь на событие. Заметьте, **I-class** :point_up:.

**Return:** логическое условие, сообщающее о, как минимум, одной регистрации на источник.

```
void chEvtDispatch (const evhandler_t *handlers, eventmask_t events)
```

Очень интересная функция. Первым аргументом передается массив указателей на функции с прототипом: `void event_handler(eventid_t id)`.

Вторым аргументом передается маска событий, по которой выполняются обработчики, установленные в массиве.

Таким образом, `eid` в маске соответствует индексу в массиве обработчиков. если в маску установлены `EVENT_MASK(3) | EVENT_MASK(2) | EVENT_MASK(0)`, то функция вызовет последовательно обработчики под индексами 0, 2, 3. Соответственно, размер массива обрабочиков должен соответствовать максимальному `eid`, установленному в маске, иначе могут быть проблемы с выходом за границы массива.

```
eventmask_t chEvtGetEventsX (void)
eventmask_t chEvtAddEvents (eventmask_t events)
eventmask_t chEvtAddEventsI (eventmask_t events)
eventmask_t chEvtGetAndClearEvents (eventmask_t events)
eventmask_t chEvtGetAndClearEventsI (eventmask_t events)
```

Данная группа функций работает с масками, которые находятся на стадии ожидания обработки (публикатор оповестил, но слушатель не вызвал ни одного Wait).

**Return:** маска событий.

Их назначение больше подходит к упрощённому механизму, поэтому кратко опишу их функционал:

`chEvtGetEventsX()` - получить маску ожидающих обработки событий.

`chEvtAddEvents()` - добавить к маске ожидающих событий свои (по факту влезть в механизм без проверки на регистрацию).

`chEvtGetAndClearEvents()` - проверить какие из переданных аргументом события ожидают (операция AND), очистить те, которые совпали и вернуть их (return).

```
void chEvtSignal (thread_t *tp, eventmask_t events)
void chEvtSignalI (thread_t *tp, eventmask_t events)
```

Прямое оповещение маской событий конкретному потоку. Первый аргумент - указатель потока, второй - сформированная маска событий. Без регистрации, без слушателей и флагов. Один поток вызывает какую-нибудь функцию Wait с указанием маски ожидания, другой вызывает Signal с маской и, если маски пересеклись (AND), то Wait вернет маску событий, которые случились (пересеклись).

В одном из примеров книжки есть пример прямого использования сигналов.

### Пример использования
#### Примеры инициализации:

```
EVENTSOURCE_DECL(serial_src);

// OR ---------------------

event_source_t serial_src;
chEvtObjectInit( &serial_src );
```

#### Регистрируемся:

```
/* Initialize source */
/* Source should be accessible to broadcaster */
event_source_t serial_src;
chEvtObjectInit( &serial_src );

/* Listener */
event_listener_t serial_lnr;

/* Variants to register serial event listener on eid 2 */
/* For this thread serial events == event 2 */
/* Register 1 */
chEvtRegister( &serial_src, &serial_lnr, 2 );

/* Register 2 */
chEvtRegisterMask( &serial_src, &serial_lnr, EVENT_MASK(2) );

/* Register 3 (with flags) */
/* Flags should be accessible to broadcaster */
#define TX_ERROR_FLAG     (1 << 0)  // 0x01
#define RX_ERROR_FLAG     (1 << 1)  // 0x02
#define BYTE_TRANSMITED_FLAG  (1 << 2)  // 0x04
#define BYTE_RECEIVED_FLAG   (1 << 3)  // 0x08

/* Register on interested flags */
/* Flags are concatenated (gathered) with bit OR operation */
chEvtRegisterMaskWithFlags( &serial_src, &serial_lnr, EVENT_MASK(2), BYTE_TRANSMITED_FLAG | BYTE_RECEIVED_FLAG );
```

В данных вариантах происходит регистрация слушателя на событие по ID 2 в маске. *[По факту, когда произойдет событие, в маске событий слушателя установится бит `(1 << 2)`.]* В последнем варианте слушателя интересуют конкретные флаги. Если публикатор оповещает о событии с флагом `RX_ERROR_FLAG`, то слушатель не получит оповещения.

#### Ждем события и обрабатываем:

```
/* Suppose, we have events on ID`s 2, 4, 7 */
/* --- One --- */
/* Wait for event 2 */
eventmask_t evt = chEvtWaitAny(EVENT_MASK(2));

/* --- Any --- */
eventmask_t evt = chEvtWaitAny(ALL_EVENTS);
if ( evt & EVENT_MASK(2) ) { /* handle event 2 */ }
if ( evt & EVENT_MASK(4) ) { /* handle event 4 */ }
if ( evt & EVENT_MASK(7) ) { /* handle event 7 */ }

/* --- All --- */
/* Wait to happen event 2 and 7 together */
eventmask_t evt = chEvtWaitAll(EVENT_MASK(2) | EVENT_MASK(7));
```

На функцию `chEvtWaitOne()` можно натравить и несколько масок типа `EVENT_MASK(2) | EVENT_MASK(7)`, и если случится оба события, то в маске будет только младший случившийся (2). О седьмом будет ничего неизвестно. 

**Вывод:** функция будет работать, но она не предназначена для работы со мноеством событий (написано же: One :sunglasses:).

#### Рассылка, широкое оповещение:

```
/* Variant 1 */
/* Notify about serial event happened */

chEvtBroadcast( &serial_src );

/* Variant 2 (with flags, see register) */
/* Strange situation, but look at flags concatenation */
/* Listeners will get notification only if they are interested in flags */

chEvtBroadcastFlags( &serial_src, RX_ERROR_FLAG | TX_ERROR_FLAG );
```

#### Проверка флагов:

```
if ( evt & EVENT_MASK(2) ) /* Serial event */
{
	eventflags_t flags = chEvtGetAndClearFlags(&serial_lnr);
	
	if ( flags & BYTE_TRANSMITED_FLAG ) { /* handle byte transmitted */ }
	if ( flags & BYTE_RECEIVED_FLAG ) { /* handle byte received */ }
	/* In register we didnt register on other flags */ 
}
```

### Рекомендации

Немного опишу примеры, представленные в книге. 

+ Первый пример (Multiple Events) описывает поток, который регистрируется на два события: Сеть и Последовательный порт. Событие сети регистрируется как event 0 без флагов. Событие последовательного порта регистрируется как event 1 с конкретными флагами. Далее в цикле идет постоянная проверка на номер события и, в случае события последовательного порта, соответсвующие флаги.

+ Во втором примере использован механизм прямого асинхронного оповещения. В обработчике прерывания UART по каналу `RX CH_IRQ_HANDLER(UART_RX_IRQ)` идет установка маски событий и оповещается с помощью функции `chEvtSignalI()` (всё-таки прерывание). В коде потока происходит ожидание абсолютного любого оповещения о событиях, при этом результат функции `chEvtWaitAny()` проверяется на соответствие отдельным маскам каждого события. Важно отметить, для работы упрощенного механизма в коде потока `main()` был получен указатель на поток `uart_thread`.

**Резюмируя:** механизм нереально сильный и имеет шировкие возможности. Одной из наиболее важных особенностей является функционал широковещательного оповещения (*broadcast*), что сложно осуществимо с остальными механизмами (IMHO). В доках по ссылке можно найти основные операции, если интересует терминология.

###Полезные ссылки
1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_events)
2. [Доки](https://slack-redir.net/link?url=http%3A%2F%2Fchibios.sourceforge.net%2Fdocs3%2Frt%2Fgroup__events.html)
