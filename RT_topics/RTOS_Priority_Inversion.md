# Инверсия приоритетов 

Ещё одна проблема, которая проявляется на мультипоточных системах с использованеим примитивов синхронизации. Проблема *инверсии приоритетов* возникает обязательно в системах с распределённым приоритетом. Рассмотрим график временной диаграммы из первой ссылки:

<p align="center">
<img src="http://www.playembedded.org/blog/wp-content/uploads/2016/10/Example-2-1-threads-flow.png">
</p>

Как видно, в системе присутствует шесть потоков, включая *Idle* и спящий *main*. Если интересен код данного распределения - велком по первой ссылке :blush:.

Важно заметить, что Т1 и Т4 разделяют общий ресурс. При этом, когда Т4 захватил ресурс (захватил мютекс), Т1 встает в состояние Ready, вытесняет Т4 и пытается также захватить ресурс, что приводит к блокировке и ожиданию окончания работы Т4.

В данной ситуации все было бы неплохо, если бы только не потоки Т2 и Т3, которые для своей работы вытесняют Т4. Таким образом, во время захвата ресурса потоком Т4, поток Т1 становится приоритетом ниже Т4 и, как следствие, всех остальных (кроме Idle).

В чём состоит проблема? Т1 приходится ожидать потока Т4, даже при том, что Т1 выше по приоритету Т4. Так как Т2 и Т3 выше Т4 по приоритету, они растягивают работу Т4, что приводит к увеличению jitter потока Т1, а более того, может привести к нарушению deadline.

Так как решить данную проблему? Давайте на секунду представим: как только Т1 заблокируется на синхронизации, мы поднимем приоритет Т4 до приоритета Т1. Сделаем это на чуть-чуть, пока Т4 не отпустит блокировку. Только тсс.., сделаем это тихо, Т2 и Т3 не смогут поработать (теперь они не выше Т4), а Т4 быстренько отработает и отдаст блокировку Т1, что в разы уменьшит jitter. А теперь все то же самое, но с картинкой:

<p align="center">
<img src="http://www.playembedded.org/blog/wp-content/uploads/2016/10/Example-2-2-threads-flow.png">
</p>

И вуаля :sunglasses:. Похоже на то, что проблема с постоянным вытеснением Т4 была решена. Теперь дело за малым - решить вопрос, какого лешего на один общий ресурс повесили самый низкий и самый высокий приоритет? Но это уже другая история - дело за архитектурой. 

Несмотря на то, что пример действительно не совсем ясный с точки зрения приложения, он отлично демонстрирует принцип работы наследования приоритетов.

<u> Данный механизм реализован в ChibiOS и для разработчиков нет никакой необходимости думать о его включениий. </u>

Вот так просто была рассмотрена проблема инверсии приоритетов и ее решение - наследование приоритетов.
Таким образом, если низкоприоритетный поток блокирует ресурс (примитив синхронизации, конечно), а затем на данном ресурсе блокируется поток с бoльшим приоритетом - приоритет первого поднимается до уровня второго для уменьшения задержек в выполнении задач.
Также о реальном появлении проблемы можете почитать в данной [статье](http://www.cse.chalmers.se/edu/year/2015/course/EDA222/Documents/Misc/Report_MarsPathFinder.pdf).

### Рекомендации

Ну тут можно сказать следующее - рассмотрение данной проблемы является скорее общеобразовательным, нежели сильно прикладным. Важно просто не забывать, что существование решения проблемы инверсии зависит от конкретной реализации системы.
С другой стороны, автоматизированный механизм наследования также требует некоторых ресурсов, и, например, в случае марсохода был отключен, что привело к последствиям. 


### Полезные ссылки
1. [Playembedded (глава 3)](http://www.playembedded.org/blog/explanation-multithreading-chibios/)
2. [Wiki](https://en.wikipedia.org/wiki/Priority_inversion)
3. [Марсоход](http://www.cse.chalmers.se/edu/year/2015/course/EDA222/Documents/Misc/Report_MarsPathFinder.pdf)
