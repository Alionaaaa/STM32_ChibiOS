# Семафоры

## Описание

Пост будет длинным, поэтому готовьтесь :smiling_imp:

Ещё один примитив синхронизации на повестке дня.
Обычно тема семафора не имеет разделения, но относительно ChibiOS это две схожие темы, поэтому здесь мы рассмотрим следующие виды:
+ счетные семафоры - *counting semaphores*;
+ бинарные (двоичные) семафоры - *binary semaphores*.

Начнем мы с темы, свойственной для многих ОСРВ. Потом посмотрим на разновидность, которая существует в ChibiOS (и, возможно, в других системах) и на это есть свои причины.

## Счётные семафоры

Немного разберем механизм семафора, он имеет счётчик. Сам семафор создается с определённым количеством в счетчике. Во время работы семафор можно взять или отпустить (отсигналить). (Если найдете другие варианты - сообщите :grin:). При этом не стоит ассоциировать с жёсткой блокировкой. Когда семафор берётся, его счётчик уменьшается на единицу. Когда отпускается - счётчик увеличивается.
Если счётчик доходит до нуля и ещё другой поток пытается его взять, то он заблокируется в ожидании, когда кто-то другой отпустит семафор (увеличит его счётчик). Таким образом можно вывести некоторые правила:

+ Счетчик > 0 - взятие семафора просто уменьшает счетчик
+ Счетчик == 0 - все последующие захваты блокирую захватчиков (уводя счетчик в минус)
+ Счетчик < 0 - продолжаем блокировать захватчиков, которые будут ждать освобождения кем-нибудь семафора).

Немного разъясню ситуацию. Семафор инициализирован на счётчик пять. Семь потоков пытаются захватить семафор, пять уменьшаю счётчик до нуля и продолжают работать, остальные два уводят счётчик в минус и ждут, пока кто-нибудь из пяти работающих отпустят семафор (увеличат счётчик). Один из работающих потоков (из пяти) отпускает семафор (сигналит) и в результате один из двух ожидающих (кто первый попытался захватить) освобождается и продолжает работу.

**Важно отметить для понимания** - если бесконечно отпускать семафор (сигналить), то его счётчик будет бесконечно увеличиваться. Это стоит учитывать при проектировании. То есть, можно инициализировать семафор на счётчик десять, при этом лишние сигналы будут его увеличивать (каждый сигнал +1 к счётчику).

Много много абстрактных слов, давайте немного прикладных вещей.

Рассмотрим стандартную проблему *"Производитель - Потребитель" (Producer - Consumer)*. Представьте красивую кухню фирменного ресторана. У нас есть пять поваров и пять официантов, а также стол на 20 блюд. Повара готовят пасту и ставят на стол, официанты забирают их и уносят посетителям. В такой системе без синхронизации может получиться коллизия, официанты слишком долго носят или посетителей не так много, а повары стругают и стругают без остановки.

Счетный семафор здесь выступает инструментом для синхронизации системы, в которой стол для блюд является разеляемым ресурсом.

Делаем два семафора, один (1) указывает на заполненность и инициализируется с счётчиком 20 (по мест на столе). Другой (2) указывает на наличие блюд на столе и инициализируется нулем.

Опустим синхронизацию доступа к столу, сейчас это не так важно. Важнее описать принцип работы.

Как только повар сделал пасту, он пытается взять семафор (1). Если семафор удачно взят, паста кладётся на стол и повар сигналит семафор (2).

Официант пытается взять семафор (2). Если он удачно взят - со стола берётся блюдо, сигналится семафор (1) и относится к посетителям.

Особенность работы потоков в том, что если стол заполнен, то семафор (1) был взят 20 раз поваром и ни разу не отсигнален официантом - стол заполнен. В этой ситуации попытка 21-го захвата поваром будет заблокирована до хоть одного сигнала официанта.

Аналогичная ситуация с официантом. Изначально семафор (2) на нуле, поэтому захват официанта блокируется до сигнала со стороны повара. Концептуально, официант ждет хотя бы одного блюда. Если блюдо появилось, семафор отпускает официанта и тот сигналит о свободном месте на столе семафором (1).

Вот так простенько синхронизируется доступ к столу с блюдами 

## Двоичные семафоры

Тут дела обстоят проще. Если в счётных семафорах нам приходилось рассматривать состояние семафора с точки зрения состояния его счётчика, то двоичных облегчают нам жизнь и сообщают о своей простоте. Двоичные семафоры имеют всего два состояния - **Захвачен / Свободен**.

*"Воу, так это же мютексы"* - может сказать читатель, если слышал об указанных. Хочу вас заверить, тут есть различия и достаточно весомые.

**Самое главное отличие**: управление блокировкой может производиться из разных потоков. Если мютекс может освободить только тот поток, который его захватил, то двоичный семафор может захватить один поток, а освободить (отсигналить) другой. 

Использование такого механизма предполагает сильные различия в использовании. Теперь это не обертка над кодом (мютекс), а скорее переходы состояний.

Например, двоичный семафор может быть инициализирован захваченным, а его освобождение его сигнализирует о наступлении какого-либо события.

Также, у двоичных семафоров нет управления приоритетами (решения проблемы "Инверсии приоритетов").

По факту бинарный семафор имеет в счётчике либо единицу (*Свободен*), либо 0 и отрицательные числа (*Захвачен*). Чем глубже захват (негативнее счетчик), тем больше надо сигналов, чтобы их все освободить. Работать, при этом может, похоже, только один поток.

## Программное использование

Ну а теперь много-много API по семафорам.

### Счётные семафоры

Для начала тип объекта (структура).
```
semaphore_t sem;
```

Инициализация:
```
void chSemObjectInit (semaphore_t *sp, cnt_t n)
```

Указатель на объект семафора дело понятное, аргумент n обозначает начальное состояние счетчика на момент инициализации.

```
SEMAPHORE_DECL(name, n)
```

Статический инициализатор, в котором в качестве имени передается название объекта. Второй аргумент аналогичен инициализации через функцию.

```
void chSemReset (semaphore_t *sp, cnt_t n)
void chSemResetI (semaphore_t *sp, cnt_t n)
```

Сброс семафора до состояния, указываемого вторым аргументом. Сбросив семафор, все, кто ждут - освобождаются с возвратом `MSG_RESET`.

```
msg_t chSemWait (semaphore_t *sp)
msg_t chSemWaitS (semaphore_t *sp)
msg_t chSemWaitTimeout (semaphore_t *sp, sysinterval_t timeout)
msg_t chSemWaitTimeoutS (semaphore_t *sp, sysinterval_t timeout)
```

Взятие семафора (захват - уменьшение счетчика на единицу). Есть функции с таймаутом. Можно воспользоваться константами `TIME_IMMEDIATE` и `TIME_INFINITE`.

**Return:**
`MSG_OK` - семафор удачно захвачен и тут не важно, был ли счетчик положительным или поток завис, в результате семафор отдает управление (надеюсь) и возвращает этот код
`MSG_RESET` - вот мы ждем пока кто-нибудь отсигналит семафор, потому что слишком много захватили и кто-то (вероятно нехороший) пустил `chSemReset()` семафор и сбросил его
`MSG_TIMEOUT` - в случае наличия таймаута в функции, по случившемуся может вернуться этот код

```
void chSemSignal (semaphore_t *sp)
void chSemSignalI (semaphore_t *sp)
```

А вот теперь и сигналить умеем по семафору. Ничего не возвращаем, да и ждать нечего - это просто увеличение счетчика.

```
void chSemAddCounterI (semaphore_t *sp, cnt_t n)
```

Функция добавления к счетчику семафора не просто +1, а целого `n`.

```
msg_t chSemSignalWait (semaphore_t *sps, semaphore_t *spw)
```

Это интересная функция, она сразу сигнали в один семафор и захватывает другой, причем все это атомарно (написано в доках). Первый аргумент `sps` - кому отсигнали, второй `spw` - кого захватить.

**Return:**
`MSG_OK` - захватили и семафор нас отпустил
`MSG_RESET` - во время ожидания кто-то сбросил

```
void chSemFastWaitI (semaphore_t *sp)
```

Хитрая функция для прерывания - быстрое уменьшение счетчика, лучше вызывать ее, когда известно, что счетчик положителен. Внутри по коду проверок вообще нету

``` 
void chSemFastSignalI (semaphore_t *sp)
```

Аналогичное быстрое увеличение счетчика, никаких проверок

``` 
cnt_t chSemGetCounterI (semaphore_t *sp)
```

Также функция для прерывания, вот этим можно понять, что там со счетчиком семафора.

**Return:** значение счетчика семафора.

### Двоичные семафоры 

Тут все немного проще, названия функций отличаются не сильно, поэтому не запутайтесь
``` 
binary_semaphore_t *b_sem
```

Тип объекта (струткуры) двоичного семафора.
```
BSEMAPHORE_DECL(name, taken)
```
или
```
void chBSemObjectInit (binary_semaphore_t *bsp, bool taken)
```

Вот такими способами можно инициализировать. Флаг `taken` сообщает о состоянии семафора на начало работы (захвачен/свободен). Как видно, флаг логический.

```
void chBSemResetI (binary_semaphore_t *bsp, bool taken)
void chBSemReset (binary_semaphore_t *bsp, bool taken)
```

Сброс семафора в состояние, указанное флагом `taken`.

```
msg_t chBSemWait (binary_semaphore_t *bsp)
msg_t chBSemWaitS (binary_semaphore_t *bsp)
msg_t chBSemWaitTimeoutS (binary_semaphore_t *bsp, sysinterval_t timeout)
msg_t chBSemWaitTimeout (binary_semaphore_t *bsp, sysinterval_t timeout)
```

Функии захвата семафора, по аналогии со счетными семафорами, все тот же принцип.

**Return:**
`MSG_OK` - семафор удачно захвачен
`MSG_RESET` - был вызван `chBSemReset()`
`MSG_TIMEOUT` - в случае наличия таймаута в функции

```
void chBSemSignalI (binary_semaphore_t *bsp)
void chBSemSignal (binary_semaphore_t *bsp)
```

Функции освобождения двоичного семафора.

```
bool chBSemGetStateI (binary_semaphore_t *bsp)
```

Функция проверки состояния семафора, как видно сделана для прерывания (I-class). Для потоков можно проверить с помощью `chBSemWaitTimeout()` с таймаутом `TIME_IMMEDIATE`.

### Пример

Здесь попробуем привести простой пример "Производитель - Потребитель" на коде.

```
#define TABLE_SIZE 20

semaphore_t full_sem;     /* Init with func */
SEMAPHORE_DECL(slot_sem, 0); /* Init statically */

pasta_t kitchen_table[TABLE_SIZE];

static THD_FUNCTION(Producer, arg) 
{
	pasta_t new_pasta = producePasta();
	/* Stop if it is full */
	chSemWait(&full_sem);
	layOnTheTable();
	/* Tell them there is a dish */
	chSemSignal(&slot_sem);
}

static THD_FUNCTION(Consumer, arg)
{
	/* Wait for a dish */
	chSemWait(&slot_sem);
	pasta_t new_pasta = getFromTheTable();
	/* One more place for new dish */
	chSemSignal(&full_sem);
	/* For example this function has really great Jitter */
	/* May be 1 sec, may be 1 minute */
	serveTheCustomers(new_pasta);
}

void main(void) 
{
	...
	chSemObjectInit(&full_sem, TABLE_SIZE);
	...
}
```

## Рекомендации
Семафоры являются механизмом более легким по сравнению с мютексами, тем не менее они не имеют некоторых "наворотов", которыми мютексы управляют. Двоичные семафоры так вообще считаются очень быстрым механизмом (по словам автора) 

### Полезные ссылки
1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_semaphores)
2. [Доки](http://chibios.sourceforge.net/docs3/rt/group__semaphores.html)
3. [Больше доков](http://chibios.sourceforge.net/docs3/rt/group__binary__semaphores.html)
4. [Хабр](https://habrahabr.ru/post/261273/)
