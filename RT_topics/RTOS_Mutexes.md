# Мютексы

## Описание

Мютексы - это один из инструментов, которые взаимодействуют с диспетчером для реализации многозадачности в ОСРВ. Его также можно выделить по особенному признаку, так как он относится к обязательным элементам ОСРВ для реализации исключительного доступа к ресурсам. Такие вещи называются - **примитивы синхронизации**.

Основным его назначением является **синхронизация доступа к разделяемым ресурсам (shared resources)**.

Под разделяемыми ресурсами можно понимать что угодно в различных задачах:
+ запись в буффер (буффер),
+ чтение из интерфейса (интерфейс),
+ подсчет яблок (счётчик яблок),
+ установка полей структуры (структура).

Ресурсы называются разделяемыми, если они задействованы в нескольких задачах.

Примитивы синхронизации нацелены на синхронизацию доступа к таким ресурсам, в которых критична целостность выполнения операций на этими ресурсами.

Часто мютексы ассоциируют с дверью, которая как раз закрывает разделяемый ресурс. Положим, ресурсом является книга, в которую пишут свои данные разные люди (потоки). Каждый человек имеет задачу раз в день написать в книгу: номер записи, фамилию, время записи и комментарии. Запись производится последовательно, то есть человек не имеет выделенную строку под себя, он продолжает записывать данные сразу за предыдущими данными. Всего людей десять и каждый в течении дня может записать в любое время. Так вот, если один человек пишет свои данные, но приходит другой, который торопится (приоритет выше), прерывает его и сразу пишет свое, то получается:

```
10 - Васеч11 - Важнечкин - 10:30 - Тороплюсь
кин - 10:29 - Как-будто меня сейчас прервут
```

Хотя ожидаемо, что запись будет идти следующим образом:

```
10 - Васечкин - 10:29 - Как-будто меня сейчас прервут
11 - Важнечкин - 10:30 - Тороплюсь
```
(в конце своей записи каждый ставит перенос строки)

Таким образом мютекс выступает с задачей синхронизации доступа в виде двери для доступа к данной книге. Васечкин заходит, закрывает за собой дверь, и пока он не закончит свою запись, Важнечкин будет ждать у двери. Как только первый закончит, второй ворвется и начнет безудержную запись.

Здесь важно отметить, что в данной ситуации вопрос приоритетов стоит достаточно остро, так как получается, что при выполнении низкоприоритетной задачи высокий приоритет ждёт ее окончания. Здесь нет ошибки, все так и происходит, хотя конкретные особенности приоритетов и примитивов сихронизации предлагается рассмотреть в части "Инверсия приоритетов - наследование приоритетов".

Если перейти от примеров к конкретной системе ChibiOS, то можно отметить, что мютекс может находиться в двух состояниях: *захвачен* и *свободен*. Захват мютекса проиходит первым потоком, вызвавшим функцию захвата, а все дальнейшие попытки другими потоками захватить мютекс до того, как он был освобожден "первым захватчиком" приведут к блокировке. При блокировке поток отдает управление диспетчеру с указанием на то, что он ожидает освобождения мютекса.

Мютекс может освободить только тот поток, который его захватил.

## Программное использование

Как определить объект мютекса?

Два способа:

+ Создать объект (структуру) мютекста и инициализировать с помощью функции:

```
mutex_t mtx;
chMtxObjectInit(&mtx);
```

+ Определить и инициализировать переменную с помощью функции-макроса:
```
MUTEX_DECL(mtx);
```

Как заблокировать мютекс?

```
void chMtxLock (mutex_t *mp)
void chMtxLockS (mutex_t *mp)
```

Как разблокировать мютекс?

```
void chMtxUnlock (mutex_t *mp)
void chMtxUnlockS (mutex_t *mp)
```

Можно ли проверить, захвачен мютекс или нет без входа в блокировку?
Да, для этого можно использовать функцию

```
bool chMtxTryLock (mutex_t *mp)
bool chMtxTryLockS (mutex_t *mp)
```

которая возвращает `true`, если мютекст захвачен, и `false`, если мютекст не удалось захватить (он уже захвачен и вызов `chMtxLock()` приведет к блокировке потока). При этом сама функция не вызывает блокировки.

Можно также заметить, что функции мютексов (из API) не включают полей `Timeout`, а также не имеют I-class функций. Это важно помнить при проектировании системы.

## Рекомендации
Сам по себе мютекс является тяжелым механизмом, поэтому его использование не стоит рассматривать первым .
Из рекомендаций разработчик советует пользоваться функцией `chMtxTryLock()`, так как проверка захвата позволяет обойти блокировку и выполнить, например, другие задачи, а затем попробовать захватить мютекс снова. Важно отметить, что это лишь рекомендация и все выборы строятся на основе требований к системе и логики работы программы 

### Полезные ссылки
1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_mutexes)
2. [Доки](http://chibios.sourceforge.net/docs3/rt/group__mutexes.html)
