# Синхронные сообщения

## Описание

Достаточно интересный механизм с точки зрения работы. В качестве аналогии могу привести механизм SRR (Send-Receive-Reply) в системе QNX. SRR и данный инструмент являются механизмами IPC (*inter process communication - взаимодействие внутри процесса*). 

Принцип работы рассматриваемого механизма несложный, но нестандартный с точки зрения рассматриваемых ранее инструментов.

В использовании данного инструмента происходит взаимодействие двух потоков (из API для прерываний всего одна функция и то проверки) в структуре сервер-клиент. Один из потоков выступает в качестве клиента, который отправляет запрос и ждёт ответа. Сервер же ждет запросы, получает их и отвечает. В данной схеме данные передаются в обе стороны - как во время запроса, так и во время ответа. Также существует возможность распределения сообщений по приоритетам в зависимости от приоритета потока-клиента (тот кто отправляет сообщение) вместо очереди по принципу FIFO. Настраивается данный режим константой `CH_CFG_USE_MESSAGES_PRIORITY` в `chconf.h`.

Таким образом, механизм, который мы рассмотрим, представляет собой взаимодействие, когда один поток отправляет сообщение и встает в ожидание ответа. Как только другой поток принимает сообщение, он его обрабатывает и отправляет ответ. При получении ответа первый поток восстанавливает управление с полученным ответом от сервера.

## Программное использование

Важно отметить, что все передаваемые сообщения имеют тип `msg_t`. При этом, через эти сообщения можно передавать указатели. Работает такой механизм с указателями, так как система микроконтроллера имеет единую память без разграничений.

### Функционал 

Перейдем к функционалу. Следует упомянуть функцию, которая понадобится для получения указателей на потоки, которыми пользуется функционал синхронных сообщений. Указатель на поток имеет тип:

```
thread_t *tp;
```

Для получения данного указателя можно использовать функцию внутри потока, чтобы получить указатель на себя

```
thread_t *chThdGetSelfX (void)
```

Также получить указатель на поток можно при создании потока функцией

```
thread_t *chThdCreateStatic (void *wsp, size_t size, tprio_t prio, tfunc_t pf, void *arg)
```

А теперь к функционалу синхронных сообщений
```
msg_t chMsgSend (thread_t *tp, msg_t msg)
```

Функция клиента. Отправляет сообщение `msg` по указателю на функцию `tp`. После вызова поток встает в ожидание ответа (отдает управление).

**Return**: сообщение-ответ от сервера `chMsgRelease()`.

```
thread_t *chMsgWait (void)
```

Функция сервера. Встает в ожидание (отдает управление) сообщения от любого потока. Возвращает управление, когда к потоку пришло сообщение.

**Upd**. По исходникам видно, что потоку-серверу не обязательно стоять в ожидании сообщения. У потока существует очередь сообщений, в которую добавляются сообщения от функции `chMsgSend()`.

**Return**: указатель на поток, от которого пришел запрос.

```
msg_t chMsgGet (thread_t *tp)
```

Функция сервера. Получает сообщение, которое пришло от потока `tp`. Рекомендуется использовать после функции `chMsgWait()`.

Return: сообщение-запрос от клиента `chMsgSend()`.

```
void chMsgRelease (thread_t *tp, msg_t msg)
void chMsgReleaseS (thread_t *tp, msg_t msg)
```

Функция сервера. Отвечает клиенту `tp` сообщением `msg`. Функцию необходимо вызвать для того, чтобы вывести клиента из режима ожидания.

```
bool chMsgIsPendingI (thread_t *tp)
```

Функция для проверки наличия сообщений к потоку `tp`.

Return: логический флаг наличия сообщений к потоку `tp`.

### Пример

Здесь будет простой пример сервер-клиента.

```
static thread_t *server;
static THD_FUNCTION(ServerThread, arg) {
	while (true) {
		thread_t *sender = chMsgWait();
		msg_t client_msg = chMsgGet(sender);
		
		/* Process message */
		if ( client_msg > 10 )
			high_value();
		else
			low_value();
		
		/* Reply with MSG_OK */
		chMsgRelease(tp, MSG_OK);
	}
}

static THD_FUNCTION(ClientThread, arg) {
	int i = 0;
	while (true) {
		/* Wait for reply */
		chMsgSend(server, i);

		if ( ++i > 20 )
			i = 0;
			
		chThdSleepSeconds(1);
	}
}

void main(void) {
	...
	server = chThdCreateStatic(..., ClientThread, NULL);
	...
}
```

### Рекомендации

Механизм позволяет автоматически синхронизироватьиспользование ресурсов за счет того, что передача сообщений блокирует одну из сторон, в то время, когда вторая активно работает. При этом необходимо не забывать о том, что клиент всегда ожидает ответа от потока, при этом функционал не предоставляет возможности отхода по таймауту. По этой причине в данной механизме накладываются некоторые неявные связки функций в последовательности использования :grin:

### Полезные ссылки
1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_messages)
2. [Доки](http://chibios.sourceforge.net/docs3/rt/group__messages.html)
