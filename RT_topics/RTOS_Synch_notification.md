# Синхронное пробуждение (нотификация)

## Описание

Почему-то при написании заголовка в голове всплыла следующая картинка.

Десяток потоков разом просыпаются и такие 

<p align="center">
<img src="https://akphoto3.ask.fm/841/841/876/-379996987-1smrn18-4nirtmjl9ppn4da/original/luntik_27570095_orig_.jpg">
</p>

А теперь к самой теме, инструмент в сабже (*subject - тема*) является, наверное, лучшим инструментом для начала знакомства с классом инструментов, которые позволяют разработчику управлять взаимодействием потоков (не считая `sleep` и `yield`).

Принцип данного инструмента достаточно прост, поток переходит в состояние `Sleep` и ожидает, пока кто-нибудь его не пробудит. При этом существует возможность передачи сообщения.

Данный инструмент является синхронным, так как пробуждение срабатывает только если поток ждет пробуждения. Вызов пробуждения без ожидающего потока не приводит к запоминанию, то есть пробуждение просто потеряется и поток, даже если через одну микросекунду после пробуждения встает в ожидаение, все равно джет следующего пробуждения.
Также важно отметить, что данный механизм работает по принципу один к одному. Одно пробуждение может пробудить лишь один поток. Нет функций "пробудить всех".

## Программное использование

А теперь конкретно к ChibiOS. Для начала функции, отвечающие за постановку в ожидание пробуждения.

```
msg_t chThdSuspendS (thread_reference_t *trp)
msg_t chThdSuspendTimeoutS (thread_reference_t *trp, sysinterval_t timeout)
```

Обе функции являются S-class функциями. Функция без `timeout` устанавливает поток в бесконечное ожидание пробуждения. Вторая функция характерна тем, что ей можно задать время, в течении которого поток будет ждать пробуждения. По истечении данного интервала поток выходит с возвратом `MSG_TIMEOUT`. Вызов `chThdSuspendS()` аналогичен вызову `chThdSuspendTimeoutS()` при задании таймаута `TIME_INFINITE`.

В качестве аргумента передается указатель `trp` на переменную типа `thread_reference_t`, для привязки ожидающего потока к конкретной ссылке. Лишь один поток может перейти в ожидание по одной ссылке. В функции с таймаутом передается вторым аргументом `timeout` - количество тиков системного таймера для ожидания.

**Return:** сообщение, которое было передано при вызове пробуждения.
При таймауте (если вызвана функция с таймаутом) - `MSG_TIMEOUT`.

Теперь про функции пробуждения потока.

```
void chThdResume (thread_reference_t *trp, msg_t msg)
void chThdResumeI (thread_reference_t *trp, msg_t msg)
void chThdResumeS (thread_reference_t *trp, msg_t msg)
```

Все три функции имеют схожие прототипы и одинаковые аргументы, различаются лишь классы функций. Наличие I-class функции сообщает о возможности вызова функции из прерывания. Функциям передается тот же указатель `trp`, на который поток встает в ожидание. В качестве второго аргумента `msg` передается сообщение, которые будет возвращено из функции `chThdSuspend*()` при ее успешном завершении.

### Пример использования

```
/* The reference variable must be initially set to NULL */ thread_reference_t ext_thread_ref = NULL;

void ext_cb (EXTDriver *extp, expchannel_t channel)
{
	/* Entering I-Locked state and resuming the thread, if suspended.*/
	chSysLockFromISR();
	/* Instead of 'MSG_OK' can be any other message (msg_t)*/
	chThdResumeI(&ext_thread_ref, MSG_OK);
	chSysUnlockFromISR();
}

static THD_WORKING_AREA(waThread, 128);
static THD_FUNCTION(Thread, arg) 
{
	while (true)
	{
		/* Just wait for Resume() */
		chSysLock();
		chThdSuspendS(&ext_thread_ref);
		chSysUnlock();
		/* Other code when resumed */
	}
}
```

## Рекомендации

Описанный инструмент достаточно прост. Он хорошо применим для простой передачи синхронного сигнала между потоками (да еще и с данными - `msg_t`). Инструмент является достаточно легковесным - не сильно нагружает систему.

### Полезные ссылки
1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_threading#threads_references)
2. [Доки](http://chibios.sourceforge.net/docs3/rt/group__threads.html)
3. [Статья](http://www.chibios.org/dokuwiki/doku.php?id=chibios:howtos:wakeup)
