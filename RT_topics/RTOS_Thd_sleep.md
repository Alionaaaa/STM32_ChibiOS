# Потоки - немного о сне 

## Описание

Вопрос огранизации сна стоит дочтаточно остро. Без должно количества времени в состоянии сна можно очень быстро заметить снижение производительности :sleeping: 

А теперь перейдем к сабжу. Под сном подразумевается переход потока в состояние `Sleep` на определенный промежуток времени, задаваемый аргументами функций. Кстати, на эту тему на офф сайте есть неплохая [статья](http://www.chibios.org/dokuwiki/doku.php?id=chibios:kb:timing). В ней автор повествует о возможностях использования функционала таймингов для организации задержек во времени и периодичности выполнения кода. В данном посте предлагается рассмотреть часть из представленных в статье функций.

## Программное использование

О таймингах говорить много не приходиться, функции класса `chThdSleep*()` переводят поток в состояние `Sleep` на заданный промежуток времени. Теперь конкретно по функциям.

```
void chThdSleep(sysinterval_t time)
```

Перевод потока в состояние `Sleep` на `time` тиков системного таймера. Является базовой функцией для рассматриваемого класса функций.

```
void chThdSleepSeconds(sec)
void chThdSleepMilliseconds(msec)
void chThdSleepMicroseconds(usec)
```

Функции-обертки для установки задержки не в тиках системного таймера, а в единицах СИ времени (секунды, миллисекунды, микросекунды). Используют макро-функции `S2ST`(sec), `MS2ST`(msec) и `US2ST`(usec) для преобразования задаваемых единиц времени в тики системного таймера и последующего вызова `chThdSleep()`.

```
void chThdSleepUntil (systime_t time)
```

Перевод потока в состояние `Sleep` до наступления на системном таймере момента `time`. Если функция вызвана в момент, когда таймер уже прошел передаваемый момент времени, переход в состояние `Sleep` не происходит.

```
systime_t chThdSleepUntilWindowed (systime_t prev, systime_t next)
```

Функция похожа на предыдущую с парой отличительных особенностей. Указанные аргументы `prev` и `next` указывают промежуток времени, в течении которого поток должен находиться в состоянии `Sleep`. Если функция вызвана не в данном промежутке времени, переход в состояние `Sleep` не происходит и функция сразу возвращает управление.

**Return:**
 значение второго агрумента `next`.

### Примеры использования

```
static THD_WORKING_AREA(waBlinker, 128);
static THD_FUNCTION(Blinker, arg) 
{
	while (true)
	{
		/* Thread task code */
		chThdSleepMilliseconds(500);
	}
}
```

В данном примере нет необходимости в выполнении задач потока с четкой периодичностью, либо принимается, что время выполнения кода задачи пренебрежимо мало.

```
static THD_WORKING_AREA(waBlinker, 128);
static THD_FUNCTION(Blinker, arg) 
{
	systime_t time = chVTGetSystemTime(); // Current system time
	while (true)
	{
		time += MS2ST(20);
		/* Thread task code */
		chThdSleepUntil(time);
	}
}
```

В представленном коде производится считывание значения системного таймера, а затем, при каждой итерации задачи, прибавляется 20 мс для перехода в состояние `Sleep` до наступления результирующего момента времени. Например, системное время было считано и записано в `time` значение 200 мс. Прибавление 20 мс дает переход в состояние `Sleep` до наступления 220 мс на системном таймере. Следующая итерация будет спать до 240 мс. Таким образом организуется постоянный период выполнения задачи уже с учетом времени выполнения самой задачи.

## Рекомендации

Необходимо не забывать о том, что системный таймер имеет определенную размерность и может зранить ограниченное количество значений, даже если этот предел очень большой, предел всегда существует. Поэтому, не стоит забывать о возможных проблемах, которые могут появиться при переполнении таймера, во время проектирования 

### Полезные ссылки
1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_threading#delays)
2. [Доки](http://chibios.sourceforge.net/docs3/rt/group__threads.html)