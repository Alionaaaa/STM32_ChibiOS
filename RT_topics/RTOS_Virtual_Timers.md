# Почти реальные таймеры и время без тиков 

## Описание

Механизм, который будет рассмотрен, относится не ко всем ОСРВ. Это, можно сказать, специфичный для ChibiOS механизм, который, как мне кажется, очень полезен, поэтому предлагается его рассмотреть.
Хорошее введение, механизм не универсален, но давайте посмотрим :satisfied:. Не очень логично, но всё-таки настаиваю, так как это таки активная работа со временем, что и есть самое интересное в ОСРВ.

И всё же, почему *"почти реальные"*? Да просто потому что обычно таймеры ассоциируют с *хардварем* (железом). В данном случае механизм виртуальных таймеров не является реальной железякой, а является программным механизмом, *софтварем*, который выполняет функции реального железячного таймера.

Ну достаточно рассуждений, что же в нем такого интересного? Цитируя книгу, ссылка на которую предоставлена, виртуальные таймеры могут:
+ Работа с системным временем
+ Преобразование времени (тики в секунды и обратно)
+ Интервальное исчисление
+ Однократное (one-shot) срабатывание
+ Безтиковый (tickless) режим [меньше полинга (polling) на CPU]

Из всего этого превосходства функции в данном посте предлагается рассмотреть первые четыре функции, насколько это возможно. Пятый функционал является также специфичным для ChibiOS и более того к реализации на конкретном железе (слава абстракции :smiling_imp: - думать об этом не приходится). 

Сейчас поговорим про первые четыре, пятый опишу позже в настройке.

Теперь конерктно опишем функции:
1. **Работа с системным временем**

Здесь располагается настройка. Как бы то ни было, пора бы уже задуматься о том, что делать и как настраивать частоту ОСРВ.

2. **Преобразование времени** (тики в секунды и обратно)

Маленький функционал по преобразованию системных тиков в различные представления времени - секунды и разновидности.

3. **Интервальное исчисление**

Работа с системным таймером в терминах интервалов времени - вышли ли мы за интервал или нет.

4. **Однократное (one-shot) срабатывание**

Воот оно, самое что ни на есть важное по отношению к сабжу поста.


Вообще, если обратить внимание, странно, что мы говорим про функции виртуальных таймеров и тут цепляем системное время и работу с ним. Верно, все **ооооооочень** странно, но тут можно отметить важный факт - надо же было когда-нибудь поговорить про системное время!!!

*Ваншот* (ох, этот сленг :sweat:) таймеры и есть основная тема, все остальное (3 функции) просто посмотрим API, раз зацепили тему времени, но что греха таить - виртуальные таймеры, конечно же, работают на системном времени и, соответственно, получить разрешение выше системной частоты не выйдет, **нужно это понимать!**

## Программное использование

Саaaaaамое вкусное :pizza: :poultry_leg: :shaved_ice: :cake:, функционал, **поехали!**

### Системное время и его настройка (можно подглядеть chconf.h) 

`CH_CFG_ST_RESOLUTION` - разрешение системного таймера.
+ Во-первых, не забываем, что ChibiOS не привязан к STM32 и есть реализации на другие контроллеры. 
+ Во-вторых, макрос используется для проверки на соответствие, например, вы задаете таймер 32-битный, а в наличии только 16-битные. В результате, либо при компиляции проверка выкинет ошибку, либо во время работы система просто не запустится (так называемый `chSysHalt()`, который нарочно тормозит систему ввиду случившейся ошибки - в отладке можно увидеть).
**Резюмируя**, задаем желаемое разрешение таймера, если железо не может - система не взлетит. Обычно стандартные значения: 16 или 32. Еще важно отметить, что от установки данной переменной зависит размерность типа `systime_t` (тип `uint16_t` или `uint32_t`).

`CH_CFG_ST_FREQUENCY` - частота системного таймера (системного времени ОСРВ). Комментарии, полагаю, излишне. Что можно сказать по опыту - в обычном режиме (не tickless) на STM32 частоту **выше 1 кГц** получить трудно, все завязано на постоянном полинге CPU. Но не забывайте о том, что разговор сейчас не о конкретной железке, а абстрактно про ChibiOS. Так что в макрос задаем частоту системного таймера ОСРВ.

`CH_CFG_ST_TIMEDELTA` - вот он, макрос управления режимом: *classical / tickless*. 
+ Ставим в 0 - управляемся по классике. 
+ Ставим в != 0 - управление по tickless режиму (соответственно устанавливаем количество тиков для проверок времени/интервалов - значение 1 **запрещено**!!). 
+ Отмечу, что в конкретной реализации STM32 tickless режим реализуется на одном из таймеров (General Purpose Timer - GPT). 
+ Для классики используется системный таймер (не путать с системным таймером ОСРВ), который есть внутри STM32 и пользовать им пользователью обычно сложно.
**Резюмируя**: для *tickless* режима можно пожертвовать один GPT, зато получить буст (boost) в производительности (выше частота, меньше полинга CPU, единороги :dragon_face:, все живут дружно), для *классики* - таймер, который и так не используем, настройка проще (0 поставили и забыли), но частота ниже, так как все время вопрошаем про события таймера.

Вот и все по основной настройке системного таймера ОСРВ.

А теперь к функциям системы, что же мы может с этим всем временем сделать?)

```
systime_t chVTGetSystemTime (void)
systime_t chVTGetSystemTimeX (void)
```

Получаем значение системного времени в тиках. Что еще сказать - не знаю.
**Return:** значение системного таймера ОСРВ.

```
systime_t chVTTimeElapsedSinceX (systime_t start)
```

Полагаю, из названия функции понятно, что возвращает количество тиков с момента, заданного параметром `start`.

**Return:** количество тиков, прошедшее с момента времени, заданного `start`.

```
bool chVTIsSystemTimeWithinX (systime_t start, systime_t end)
bool chVTIsSystemTimeWithin (systime_t start, systime_t end)
```

Проверка, находится ли системное время в интервале `[start, end]`.

**Return:** логическое условие ответа на вопрос, находится ли в интервале времени?

```
bool chVTIsTimeWithinX(systime_t time, systime_t start, systime_t end)
```

Ну, как я вижу, из справки (новая версия) ее убрали, но на деле функция делает аналогичные действия, только есть вместо аргумента time задать результат функции `chVTGetSystemTime()`.

**Return:** логическое условие ответа на вопрос, находится ли в интервале времени?

Пока на этом все про работу с системным временем по версии ChibiOS 176.

А теперь будем преобразовывать время:

```
systime_t S2ST(uint32_t sec)
systime_t S2ST(uint32_t msec)
systime_t US2ST(uint32_t usec)
```

Функции преобразования времени в тики на основе настройки системного таймера ОСВР. 
Полезно для работы с реальным временем, а также универсализация по отношению к настройке системного таймера.

**Return:** количество системных тиков пропорциональных заданному времени.

```
uint32_t ST2S (systime_t ticks)
uint32_t ST2MS (systime_t ticks)
uint32_t ST2US (systime_t ticks)
```

Набор функций, обратных по функционалу к предыдущей группе - системные тики в реальное время. *С данной группой есть небольшой косяк в 176, который описан в баге открытого репозитория.*

**Return:** время соответствующее количеству переданных тиков.

### Виртуальные таймеры 

Такс, с преобразованием закончили, а теперь самое сладкое - сабж поста, **виртуальные таймеры**

Тип виртуальных таймеров имеет следующее название: `virtual_timer_t`.

```
void chVTObjectInit (virtual_timer_t *vtp)
```

Функция инициализации объекта таймера. Аргументом передается указатель на структуру таймера.

```
void chVTSet (virtual_timer_t *vtp, systime_t delay, vtfunc_t vtfunc, void *par)
void chVTSetI (virtual_timer_t *vtp, systime_t delay, vtfunc_t vtfunc, void *par)
```

Наверное, самый **сочный** функционал и **самая главная** функция. Данная функция включает виртуальный таймер (не забываем, что у него есть только режим однократного срабатывания).

Аргументы:
+ `vtp` - указатель на структуру
+ `delay` - время в тиках, через которое таймер сработает (вызовет функцию `vtfunc`)
+ `par` - указатель, который будет передан функции `vtfunc`.

Прототип функции vtfunc:
```
void vt_cb(void *par)
```

**Важно отметить**, функция обработчика вызывается из ISR и на нее накладываются все ограничения I-class контекста. По простому - это реальное прерывание.

```
void chVTReset (virtual_timer_t *vtp)
void chVTResetI (virtual_timer_t *vtp)
```

Как включили таймер, так его и выключаем.

```
bool chVTIsArmed (virtual_timer_t *vtp)
bool chVTIsArmedI (virtual_timer_t *vtp)
```

Проверяем, работает ли таймер.

**Return:** логическое условие, определяющее рабочее остояние таймера.

```
void chVTDoSetI (virtual_timer_t *vtp, sysinterval_t delay, vtfunc_t vtfunc, void *par)
void chVTDoResetI (virtual_timer_t *vtp)
```

<strike> Как называли Галыгина (из камеди) "Суслик, ****, хитрый" </strike>

Функции тоже хитрые, соответствуют своим аналогам без `Do` (выполняют те же функции), да ещё и быстрее по скорости выполнения, с одним мааааааааленьким условием: **таймер должен находиться в противоположном состоянии при вызове данных функций**. То есть, для Set таймер должен быть выключен, для Reset - включен.

## Пример использования

Возьму пример периодичного мигания диода из книжки:

```
static virtual_timer_t led_vt;

/* LED timer callback. */ 
static void led_cb(void *arg) {

	LED_toggle();  
	chSysLockFromISR();  
	chVTSetI(&led_vt, MS2ST(500), led_cb, NULL);  
	chSysUnlockFromISR(); 
}  

/* Application main function. */ 
void main(void) {  

/*  
 * System initializations.  
 * - Kernel initialization, the main() function becomes a thread and the  
 *  RTOS is active. Interrupts are enabled on chSysInit() exit.  
 */  
	chSysInit();   
	/* LED timer initialization.*/  
	chVTObjectInit(&led_vt);   
	/* Starting blinker.*/ 
	chVTSet(&led_vt, MS2ST(500), led_cb, NULL);   
	
	...;   
	
	/* Stopping blinker.*/  
	chVTReset(&led_vt);  
	LED_off(); 
}
```

Полагаю, комментарии излишне, функции `LED_off()` и `LED_toggle()` соответствуют переключениям состояния диода и могут быть реализоыаны на основе `palToggleLine()` и т.д.

### Ещё немного повторить и уточнить .........

В данном разделе хочется еще раз затронуть тему tickless режима и немного поплагиатить из книги. Как заявляет автор, классика имеет несколько особенностей:
+ увеличенное использование CPU - постоянное срабатывание запроса на прерывание (interrupt request - IRQ), что сильно зависит от частоты
+ в соответствии с первым пунктом, ограниченая частота - высокая частота приводит к пролемам производительности (CPU висит только на обработке прерывания)
+ отсюда вытекает и джиттер
+ постоянный полинг CPU вообще исключает какой-либо режим экономии энергии (некоторые контроллеры могут входить в Sleep режим с уменьшенным энергопотреблением).

И тууут на спасение приходит tickless режим :clap:.

На классике есть программный счетчик тиков и его инкремент вызывается только при системном тике (прерывание). В режиме tickless системного счетчика нет как такового (как следствие нет периодических прерываний), там все завязано на событиях. Прерывания генерируются, если запланированы какие-то события (например виртуальные таймеры).

Какие плюшки приносит tickless режим:
+ нет периодических прерываний - может войти в более глубокий сон
+ из формирования джиттера уходят периодические прерывания
+ выше частота системного таймера ОСРВ, практически снимает ограничения в частоте, ближе к частоте работы GPT.

Естественное не без особенностей, рассмотрим их:
+ код становится больше (+ сложнее), больше образ системы (файл, который пишется во flash)
+ как уже уточнялось - требует HW (hardware) таймера (должен иметь компаратор), рекомендуется 32-битный, но и пойдет 16-битный (переполняться часто будет)

Также есть еще одна **положительная особенность**, которая очень сильно играет роль при разговоре про ОСРВ. В критических зонах классика не инкрементирует системный счетчик (я как-то заявлял обратное - извиняюсь за каламбур ), в режиме tickless - инкремент не завязан на прерываниях (все таки HW регистр) и спокойно считает даже в критических зонах.

### Рекомендации

После таких рассуждений рекомендаций пока немного. Все, что можно сказать - tickless реально крут :metal:, а виртуальные таймеры можно использовать для различных задач однократного реагирования через интервал времени. Так что, еще один инструмент рассмотрен и, как уже говорилось сотню раз, не факт что всегда нужно им пользоваться, существуют разные подходы и часто одного результата можно добиться разным способами 

### Полезные ссылки

1. [Книга](http://www.chibios.org/dokuwiki/doku.php?id=chibios:book:kernel_events)
2. [Доки](https://slack-redir.net/link?url=http%3A%2F%2Fchibios.sourceforge.net%2Fdocs3%2Frt%2Fgroup__events.html)
